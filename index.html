<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cambridge Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-clear-day: linear-gradient(155deg, #edf4ff 0%, #dbe8f8 47%, #c9d8ea 100%);
      --bg-clear-night: linear-gradient(150deg, #0b1422 0%, #15253b 47%, #22344c 100%);
      --bg-clouds: linear-gradient(152deg, #d9e2ec 0%, #c7d3df 55%, #b8c6d4 100%);
      --bg-rain: linear-gradient(152deg, #8b99ac 0%, #77889e 52%, #66798f 100%);
      --bg-snow: linear-gradient(152deg, #f2f6fb 0%, #dfe8f1 56%, #cfdbe9 100%);
      --bg-thunder: linear-gradient(152deg, #334154 0%, #2a3748 51%, #1f2d3e 100%);

      --panel: rgba(255, 255, 255, 0.4);
      --panel-strong: rgba(255, 255, 255, 0.5);
      --panel-border: rgba(255, 255, 255, 0.62);
      --panel-shadow: 0 28px 72px rgba(8, 24, 46, 0.16);
      --panel-inner-glow: inset 0 1px 0 rgba(255, 255, 255, 0.82), inset 0 -24px 42px rgba(255, 255, 255, 0.1);
      --panel-edge-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.34);
      --text-primary: #0d2238;
      --text-secondary: #485d77;
      --text-muted: #6e839b;
      --accent: #1f6feb;
      --accent-soft: rgba(31, 111, 235, 0.14);
      --success: #0e9f6e;
      --success-soft: rgba(14, 159, 110, 0.13);
      --glass-hero-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.46) 0%, rgba(255, 255, 255, 0.18) 40%, rgba(255, 255, 255, 0.11) 100%);
      --glass-card-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.42) 0%, rgba(255, 255, 255, 0.15) 42%, rgba(255, 255, 255, 0.09) 100%);
      --glass-border: rgba(255, 255, 255, 0.58);
      --glass-hero-blur: 34px;
      --glass-card-blur: 36px;
      --glass-saturation: 195%;
      --glass-contrast: 108%;
      --glass-specular: linear-gradient(116deg, rgba(255, 255, 255, 0.58) 0%, rgba(255, 255, 255, 0.1) 30%, transparent 64%);
      --glass-caustic:
        radial-gradient(80% 45% at 50% -10%, rgba(255, 255, 255, 0.44), transparent 70%),
        linear-gradient(160deg, transparent 40%, rgba(255, 255, 255, 0.08) 60%, transparent 72%);
      --bg-image-filter: saturate(108%) contrast(102%);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      min-height: 100%;
      scroll-behavior: smooth;
    }

    body[data-weather*="cloud"] {
      --glass-saturation: 170%;
      --glass-specular: linear-gradient(116deg, rgba(255, 255, 255, 0.62) 0%, rgba(255, 255, 255, 0.12) 34%, transparent 64%);
      --bg-image-filter: saturate(98%) contrast(100%);
    }

    body[data-weather*="rain"],
    body[data-weather*="drizzle"],
    body[data-weather*="thunder"] {
      --glass-hero-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.14) 44%, rgba(255, 255, 255, 0.08) 100%);
      --glass-card-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.36) 0%, rgba(255, 255, 255, 0.13) 46%, rgba(255, 255, 255, 0.07) 100%);
      --glass-border: rgba(255, 255, 255, 0.5);
      --glass-hero-blur: 38px;
      --glass-card-blur: 40px;
      --glass-saturation: 155%;
      --glass-specular: linear-gradient(116deg, rgba(255, 255, 255, 0.54) 0%, rgba(255, 255, 255, 0.08) 35%, transparent 64%);
      --bg-image-filter: saturate(90%) contrast(100%);
    }

    body[data-weather*="snow"] {
      --glass-hero-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.52) 0%, rgba(255, 255, 255, 0.22) 42%, rgba(255, 255, 255, 0.14) 100%);
      --glass-card-bg: linear-gradient(122deg, rgba(255, 255, 255, 0.48) 0%, rgba(255, 255, 255, 0.2) 44%, rgba(255, 255, 255, 0.12) 100%);
      --glass-border: rgba(255, 255, 255, 0.62);
      --glass-saturation: 165%;
      --glass-specular: linear-gradient(116deg, rgba(255, 255, 255, 0.84) 0%, rgba(255, 255, 255, 0.2) 32%, transparent 64%);
      --bg-image-filter: saturate(95%) contrast(102%);
    }

    body[data-night="true"] {
      --glass-hero-bg: linear-gradient(122deg, rgba(28, 48, 72, 0.34) 0%, rgba(24, 44, 68, 0.2) 45%, rgba(18, 38, 62, 0.14) 100%);
      --glass-card-bg: linear-gradient(122deg, rgba(28, 48, 72, 0.3) 0%, rgba(24, 44, 68, 0.18) 46%, rgba(18, 38, 62, 0.12) 100%);
      --glass-border: rgba(203, 223, 248, 0.26);
      --glass-saturation: 145%;
      --glass-contrast: 104%;
      --glass-specular: linear-gradient(116deg, rgba(255, 255, 255, 0.28) 0%, rgba(255, 255, 255, 0.06) 34%, transparent 64%);
      --glass-caustic:
        radial-gradient(80% 45% at 50% -10%, rgba(200, 222, 255, 0.2), transparent 72%),
        linear-gradient(160deg, transparent 40%, rgba(180, 212, 255, 0.08) 60%, transparent 72%);
      --bg-image-filter: saturate(100%) contrast(106%);
    }

    body {
      font-family: "SF Pro Text", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", "Manrope", sans-serif;
      background: var(--bg-clouds);
      color: var(--text-primary);
      padding: 1.75rem;
      transition: background 1.2s ease;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 12% 18%, rgba(255, 255, 255, 0.52), transparent 38%),
        radial-gradient(circle at 85% 8%, rgba(255, 255, 255, 0.34), transparent 34%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.24), rgba(255, 255, 255, 0));
      pointer-events: none;
      z-index: 0;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(45% 38% at 8% 90%, rgba(110, 163, 231, 0.22), transparent 80%),
        radial-gradient(36% 30% at 95% 88%, rgba(99, 211, 171, 0.2), transparent 82%);
      pointer-events: none;
      z-index: 0;
    }

    .weather-bg {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
    }

    .ai-bg {
      position: absolute;
      inset: 0;
      background-position: center;
      background-size: cover;
      background-repeat: no-repeat;
      opacity: 0;
      filter: var(--bg-image-filter);
      transition: background-image 700ms ease, opacity 500ms ease;
    }

    .sun {
      position: absolute;
      top: 5%;
      right: 8%;
      width: 110px;
      height: 110px;
      background: radial-gradient(circle, rgba(255, 247, 218, 1) 0%, rgba(255, 227, 148, 0.65) 52%, transparent 75%);
      border-radius: 999px;
      filter: blur(0.2px);
      box-shadow: 0 0 90px 35px rgba(255, 218, 120, 0.22);
      display: none;
    }

    .moon {
      position: absolute;
      top: 7%;
      left: 8%;
      width: 72px;
      height: 72px;
      border-radius: 999px;
      background: radial-gradient(circle at 34% 32%, #fdfdfb 0%, #deddd5 60%, #c7c6c0 100%);
      box-shadow: 0 0 55px 20px rgba(229, 236, 255, 0.2);
      display: none;
    }

    .sun.visible,
    .moon.visible {
      display: block;
    }

    .stars {
      position: absolute;
      inset: 0;
      display: none;
    }

    .stars.visible {
      display: block;
    }

    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.95);
      animation: twinkle 2.8s ease-in-out infinite;
    }

    @keyframes twinkle {
      0%,
      100% {
        opacity: 0.4;
      }

      50% {
        opacity: 1;
      }
    }

    .cloud-layer {
      position: absolute;
      inset: 0;
      display: none;
    }

    .cloud-layer.visible {
      display: block;
    }

    .atmospheric-cloud {
      position: absolute;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.42), rgba(255, 255, 255, 0.13));
      border-radius: 999px;
      filter: blur(28px);
      animation: driftCloud linear infinite;
    }

    .cloud-1 {
      top: 6%;
      width: 460px;
      height: 95px;
      left: -460px;
      animation-duration: 88s;
    }

    .cloud-2 {
      top: 14%;
      width: 550px;
      height: 112px;
      left: -550px;
      animation-duration: 112s;
      animation-delay: -32s;
      opacity: 0.72;
    }

    .cloud-3 {
      top: 24%;
      width: 360px;
      height: 76px;
      left: -360px;
      animation-duration: 95s;
      animation-delay: -54s;
      opacity: 0.52;
    }

    .cloud-4 {
      top: 10%;
      width: 630px;
      height: 124px;
      left: -630px;
      animation-duration: 126s;
      animation-delay: -70s;
      opacity: 0.42;
    }

    @keyframes driftCloud {
      from {
        transform: translateX(0);
      }

      to {
        transform: translateX(calc(100vw + 760px));
      }
    }

    .rain-container,
    .snow-container {
      position: absolute;
      inset: 0;
      display: none;
    }

    .rain-container.visible,
    .snow-container.visible {
      display: block;
    }

    .raindrop {
      position: absolute;
      width: 1.5px;
      height: 21px;
      background: linear-gradient(to bottom, transparent, rgba(209, 225, 240, 0.62));
      animation: fall linear infinite;
    }

    @keyframes fall {
      to {
        transform: translateY(100vh);
      }
    }

    .snowflake {
      position: absolute;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.85);
      animation: snowfall linear infinite;
    }

    @keyframes snowfall {
      to {
        transform: translateY(100vh);
      }
    }

    .dashboard {
      position: relative;
      z-index: 1;
      width: min(1240px, 100%);
      margin: 0 auto;
      display: grid;
      gap: 1.22rem;
    }

    .hero {
      background:
        var(--glass-hero-bg);
      border: 1px solid var(--glass-border);
      border-radius: 28px;
      box-shadow: var(--panel-shadow), var(--panel-inner-glow), var(--panel-edge-shadow);
      backdrop-filter: blur(var(--glass-hero-blur)) saturate(var(--glass-saturation)) contrast(var(--glass-contrast));
      -webkit-backdrop-filter: blur(var(--glass-hero-blur)) saturate(var(--glass-saturation)) contrast(var(--glass-contrast));
      padding: 1.35rem 1.45rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1.2rem;
      flex-wrap: wrap;
      animation: riseIn 540ms ease-out;
      position: relative;
      z-index: 1;
      isolation: isolate;
      overflow: hidden;
    }

    .hero-left {
      display: grid;
      gap: 0.15rem;
    }

    .hero-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 0.95rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .greeting {
      color: var(--text-secondary);
      font-size: 0.92rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      text-transform: uppercase;
    }

    .quick-nav {
      display: flex;
      gap: 0.45rem;
      flex-wrap: wrap;
      margin-top: 0.32rem;
    }

    .temp-toggle-inline {
      margin-top: 0.42rem;
      display: inline-flex;
      align-items: center;
      gap: 0.36rem;
      width: fit-content;
      padding: 0.2rem 0.38rem;
      border-radius: 999px;
      border: 1px solid rgba(20, 58, 98, 0.18);
      background: rgba(255, 255, 255, 0.52);
    }

    .temp-toggle-label {
      font-size: 0.66rem;
      font-weight: 800;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #21466f;
    }

    .temp-unit {
      font-size: 0.67rem;
      font-weight: 700;
      color: #55708e;
      opacity: 0.6;
      transition: opacity 140ms ease, color 140ms ease;
    }

    .temp-unit.active {
      opacity: 1;
      color: #163d65;
    }

    .temp-toggle-inline .toggle {
      width: 36px;
      height: 20px;
    }

    .temp-toggle-inline .toggle-slider::after {
      width: 12px;
      height: 12px;
      top: 3px;
      left: 3px;
    }

    .temp-toggle-inline .toggle input:checked + .toggle-slider::after {
      transform: translateX(16px);
    }

    body[data-night="true"] .temp-toggle-inline {
      border-color: rgba(210, 228, 248, 0.26);
      background: rgba(18, 36, 56, 0.52);
    }

    body[data-night="true"] .temp-toggle-label {
      color: #d6e7fb;
    }

    body[data-night="true"] .temp-unit {
      color: #9eb6d3;
    }

    body[data-night="true"] .temp-unit.active {
      color: #e2efff;
    }

    .quick-link {
      text-decoration: none;
      font-size: 0.7rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #143a62;
      border: 1px solid rgba(20, 58, 98, 0.2);
      background: rgba(255, 255, 255, 0.52);
      border-radius: 999px;
      padding: 0.34rem 0.6rem;
      transition: background 180ms ease, border-color 180ms ease;
    }

    .quick-link:hover {
      background: rgba(255, 255, 255, 0.72);
      border-color: rgba(20, 58, 98, 0.32);
    }

    #clock {
      font-weight: 800;
      line-height: 1;
      letter-spacing: -0.03em;
      font-size: clamp(2.2rem, 5.7vw, 3.75rem);
      color: #10243c;
    }

    #date {
      color: var(--text-secondary);
      font-size: 0.98rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .brand-pill {
      padding: 0.6rem 0.98rem;
      border-radius: 999px;
      border: 1px solid rgba(31, 111, 235, 0.3);
      background: linear-gradient(135deg, rgba(31, 111, 235, 0.18), rgba(31, 111, 235, 0.08));
      color: #0f2c4a;
      font-weight: 800;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .hero-weather {
      min-width: 310px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.62);
      background: linear-gradient(125deg, rgba(255, 255, 255, 0.52), rgba(255, 255, 255, 0.2));
      box-shadow:
        0 14px 30px rgba(10, 30, 55, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.82);
      padding: 0.72rem 0.8rem;
      display: grid;
      gap: 0.55rem;
    }

    .hero-weather .weather-main {
      gap: 0.55rem;
    }

    .hero-weather .weather-icon {
      min-width: 42px;
      min-height: 42px;
      border-radius: 10px;
      font-size: 0.68rem;
    }

    .hero-weather .weather-temp {
      font-size: clamp(1.28rem, 2.4vw, 1.6rem);
      color: #16314e;
    }

    .hero-weather .weather-condition {
      margin-top: 0;
      font-size: 0.78rem;
      color: var(--text-secondary);
    }

    .hero-weather .weather-stats {
      gap: 0.4rem;
    }

    .hero-weather .weather-stat {
      min-height: 52px;
      border-radius: 10px;
      padding: 0.42rem 0.5rem;
      background: rgba(255, 255, 255, 0.6);
    }

    .hero-weather .weather-stat-value {
      font-size: 0.85rem;
      font-weight: 800;
    }

    .hero-weather .weather-stat-label {
      font-size: 0.62rem;
      letter-spacing: 0.03em;
    }

    .main-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 1.22rem;
      align-items: start;
    }

    body.weekend-layout .main-grid {
      grid-template-columns: minmax(300px, 0.82fr) minmax(460px, 1.18fr);
    }

    .stack {
      display: grid;
      gap: 1.22rem;
    }

    .stack[id] {
      scroll-margin-top: 6.5rem;
    }

    .stack-label {
      width: fit-content;
      font-size: 0.72rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #12385f;
      padding: 0.22rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(18, 56, 95, 0.2);
      background: rgba(255, 255, 255, 0.62);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.45);
    }

    body[data-night="true"] .stack-label {
      color: #dce9fb;
      border-color: rgba(220, 233, 251, 0.35);
      background: rgba(16, 33, 52, 0.54);
      text-shadow: none;
    }

    .full-span {
      grid-column: 1 / -1;
    }

    .card,
    .expandable {
      background:
        var(--glass-card-bg);
      border: 1px solid var(--glass-border);
      border-radius: 26px;
      box-shadow: var(--panel-shadow), var(--panel-inner-glow), var(--panel-edge-shadow);
      backdrop-filter: blur(var(--glass-card-blur)) saturate(var(--glass-saturation)) contrast(var(--glass-contrast));
      -webkit-backdrop-filter: blur(var(--glass-card-blur)) saturate(var(--glass-saturation)) contrast(var(--glass-contrast));
      overflow: hidden;
      animation: riseIn 620ms ease-out;
      position: relative;
      isolation: isolate;
      transition: border-color 220ms ease, box-shadow 220ms ease, transform 220ms ease;
    }

    .hero::before,
    .card::before,
    .expandable::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--glass-specular);
      pointer-events: none;
      z-index: 1;
      opacity: 0.88;
    }

    .hero::after,
    .card::after,
    .expandable::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: inherit;
      background: var(--glass-caustic);
      pointer-events: none;
      z-index: 1;
      opacity: 0.95;
    }

    .hero > *,
    .card > *,
    .expandable > * {
      position: relative;
      z-index: 2;
    }

    .card:hover,
    .expandable:hover {
      border-color: rgba(255, 255, 255, 0.78);
      box-shadow:
        0 38px 90px rgba(8, 24, 46, 0.22),
        inset 0 1px 0 rgba(255, 255, 255, 0.76),
        inset 0 -24px 38px rgba(255, 255, 255, 0.12),
        inset 0 0 0 1px rgba(255, 255, 255, 0.38);
      transform: translateY(-2px);
    }

    .card {
      padding: 1.05rem 1.15rem 1.2rem;
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 0.58rem;
      margin-bottom: 0.85rem;
    }

    .card-icon {
      width: 30px;
      height: 30px;
      border-radius: 9px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.69rem;
      font-weight: 800;
      letter-spacing: 0.04em;
      color: #11406b;
      border: 1px solid rgba(17, 64, 107, 0.16);
      background: rgba(17, 64, 107, 0.08);
    }

    .icon-menu {
      color: #1a4e85;
      border-color: rgba(26, 78, 133, 0.18);
      background: rgba(26, 78, 133, 0.1);
    }

    .icon-bike {
      color: #0f7a56;
      border-color: rgba(15, 122, 86, 0.2);
      background: rgba(15, 122, 86, 0.12);
    }

    .icon-transit {
      color: #9b1c1c;
      border-color: rgba(155, 28, 28, 0.25);
      background: rgba(155, 28, 28, 0.12);
    }

    .icon-charge {
      color: #0b5f2a;
      border-color: rgba(11, 95, 42, 0.24);
      background: rgba(11, 95, 42, 0.12);
    }

    .icon-sports {
      color: #7a1f1f;
      border-color: rgba(122, 31, 31, 0.24);
      background: rgba(122, 31, 31, 0.12);
    }

    .card-title,
    .expandable-title {
      font-size: 0.84rem;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #274b72;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    body[data-night="true"] .card-title,
    body[data-night="true"] .expandable-title {
      color: #d7e7fc;
      text-shadow: none;
    }

    #menuDay {
      margin-left: auto;
      font-size: 0.76rem;
      color: var(--text-muted);
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .menu-collapse-btn {
      border: 1px solid rgba(16, 32, 50, 0.2);
      background: rgba(255, 255, 255, 0.72);
      color: #1b446f;
      border-radius: 999px;
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 160ms ease, background 160ms ease, border-color 160ms ease;
    }

    .menu-collapse-btn:hover {
      background: rgba(31, 111, 235, 0.12);
      border-color: rgba(31, 111, 235, 0.35);
    }

    #menuCard.menu-collapsed .menu-collapse-btn {
      transform: rotate(-90deg);
    }

    .menu-panel-body {
      display: grid;
      gap: 0.72rem;
    }

    #menuCard.menu-collapsed .menu-panel-body {
      display: none;
    }

    .weather-card {
      display: grid;
      gap: 0.95rem;
    }

    .weather-main {
      display: flex;
      align-items: center;
      gap: 0.7rem;
    }

    .weather-icon {
      min-width: 52px;
      min-height: 52px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-soft);
      color: #12438a;
      font-weight: 800;
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      padding: 0 0.45rem;
    }

    .weather-temp {
      font-size: clamp(1.7rem, 4.8vw, 2.25rem);
      font-weight: 800;
      line-height: 1.05;
      letter-spacing: -0.02em;
      color: #102a46;
    }

    .weather-condition {
      margin-top: 0.1rem;
      font-size: 0.87rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .weather-stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.6rem;
    }

    .weather-stat {
      background: rgba(255, 255, 255, 0.66);
      border: 1px solid rgba(15, 31, 51, 0.08);
      border-radius: 12px;
      padding: 0.58rem 0.6rem;
      min-height: 64px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .weather-stat-value {
      font-size: 1.03rem;
      font-weight: 800;
      line-height: 1.1;
      color: #16324f;
    }

    .weather-stat-label {
      margin-top: 0.16rem;
      font-size: 0.71rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .weather-meta {
      font-size: 0.66rem;
      color: var(--text-muted);
      letter-spacing: 0.02em;
      line-height: 1.35;
    }

    .weather-meta a {
      color: #1f6feb;
      text-decoration: underline;
      text-underline-offset: 0.12em;
    }

    body[data-night="true"] .weather-meta {
      color: rgba(225, 238, 255, 0.78);
    }

    body[data-night="true"] .weather-meta a {
      color: #8fc4ff;
    }

    #menuContent {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.66rem;
    }

    .menu-item {
      border: 1px solid rgba(15, 31, 51, 0.09);
      background: rgba(255, 255, 255, 0.72);
      border-radius: 12px;
      padding: 0.8rem 0.86rem;
      transition: transform 180ms ease, box-shadow 180ms ease;
    }

    .menu-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(18, 43, 74, 0.09);
    }

    .menu-category {
      font-size: 0.68rem;
      font-weight: 800;
      color: #225ea6;
      text-transform: uppercase;
      letter-spacing: 0.055em;
      margin-bottom: 0.25rem;
    }

    .menu-name {
      font-size: 0.9rem;
      font-weight: 700;
      color: #132b46;
      line-height: 1.3;
    }

    .menu-desc {
      font-size: 0.77rem;
      color: var(--text-secondary);
      line-height: 1.35;
      margin-top: 0.18rem;
    }

    .menu-price {
      margin-top: 0.4rem;
      font-size: 0.78rem;
      font-weight: 800;
      color: var(--success);
      text-transform: uppercase;
      letter-spacing: 0.035em;
    }

    .menu-image-panel {
      border: 1px solid rgba(15, 31, 51, 0.09);
      background: rgba(255, 255, 255, 0.72);
      border-radius: 14px;
      padding: 0.75rem 0.85rem;
      display: grid;
      gap: 0.55rem;
      margin-bottom: 0.75rem;
    }

    .menu-image-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .menu-image-title {
      font-size: 0.7rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .menu-action-name {
      font-size: 0.84rem;
      font-weight: 700;
      color: #173a5b;
    }

    .menu-image-status {
      font-size: 0.74rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .menu-highlight-grid {
      width: 100%;
      display: grid;
      gap: 0.65rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .menu-highlight-card {
      border: 1px solid rgba(15, 31, 51, 0.12);
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.75), rgba(240, 245, 252, 0.9));
      overflow: hidden;
      display: grid;
      gap: 0.45rem;
      padding: 0.48rem;
    }

    .menu-highlight-meta {
      display: grid;
      gap: 0.12rem;
      padding: 0 0.2rem;
    }

    .menu-highlight-category {
      font-size: 0.68rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .menu-highlight-name {
      font-size: 0.8rem;
      font-weight: 700;
      color: #173a5b;
      line-height: 1.25;
    }

    .menu-highlight-image {
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(15, 31, 51, 0.1);
      background: rgba(245, 249, 255, 0.85);
    }

    .menu-highlight-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .menu-highlight-empty {
      width: 100%;
      min-height: 110px;
      border-radius: 10px;
      border: 1px dashed rgba(23, 58, 91, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 600;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-left: auto;
    }

    .toggle-label {
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
      display: inline-flex;
      align-items: center;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(16, 32, 50, 0.18);
      border: 1px solid rgba(16, 32, 50, 0.2);
      transition: background 160ms ease, border 160ms ease;
    }

    .toggle-slider::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(12, 24, 40, 0.2);
      transition: transform 160ms ease;
    }

    .toggle input:checked + .toggle-slider {
      background: rgba(14, 159, 110, 0.35);
      border-color: rgba(14, 159, 110, 0.4);
    }

    .toggle input:checked + .toggle-slider::after {
      transform: translateX(20px);
    }

    .toggle input:disabled + .toggle-slider {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .charger-summary {
      font-size: 0.78rem;
      color: var(--text-secondary);
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      margin-bottom: 0.6rem;
    }

    .charger-grid {
      display: grid;
      gap: 0.65rem;
    }

    .charger-top-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.65rem;
    }

    .charger-single-row {
      display: grid;
      gap: 0.65rem;
    }

    .charger-station {
      border: 1px solid rgba(14, 33, 54, 0.09);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.72);
      padding: 0.7rem 0.75rem;
      display: grid;
      gap: 0.45rem;
    }

    .charger-name {
      font-size: 0.86rem;
      font-weight: 700;
      color: #14314d;
    }

    .charger-meta {
      font-size: 0.72rem;
      color: var(--text-muted);
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .plug-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.4rem;
    }

    .plug {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-radius: 10px;
      padding: 0.35rem 0.5rem;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      border: 1px solid rgba(16, 32, 50, 0.1);
      background: rgba(255, 255, 255, 0.7);
      color: var(--text-secondary);
    }

    .plug.available {
      color: #0b5f2a;
      border-color: rgba(11, 95, 42, 0.22);
      background: rgba(11, 95, 42, 0.1);
    }

    .plug.in-use {
      color: #9b1c1c;
      border-color: rgba(155, 28, 28, 0.22);
      background: rgba(155, 28, 28, 0.1);
    }

    .plug.unavailable {
      color: #5b6b7f;
      border-color: rgba(16, 32, 50, 0.12);
      background: rgba(16, 32, 50, 0.05);
    }

    .departures-list {
      display: grid;
      gap: 0.5rem;
    }

    .departure-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto auto;
      gap: 0.65rem;
      align-items: center;
      border: 1px solid rgba(14, 33, 54, 0.09);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.72);
      padding: 0.58rem 0.7rem;
    }

    .departure-destination {
      font-size: 0.83rem;
      font-weight: 700;
      color: #173a5b;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .departure-time {
      font-size: 0.8rem;
      font-weight: 700;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .departure-eta {
      min-width: 62px;
      text-align: center;
      font-size: 0.73rem;
      letter-spacing: 0.03em;
      font-weight: 800;
      text-transform: uppercase;
      color: #7a1a1a;
      border: 1px solid rgba(155, 28, 28, 0.22);
      background: rgba(155, 28, 28, 0.1);
      border-radius: 999px;
      padding: 0.24rem 0.44rem;
    }

    .departure-empty {
      border: 1px dashed rgba(14, 33, 54, 0.16);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.62);
      padding: 0.8rem;
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 600;
    }

    .card-note {
      margin-top: 0.58rem;
      font-size: 0.72rem;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    #sportsUpdated {
      width: fit-content;
      margin-top: 0.2rem;
      padding: 0.22rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(26, 78, 133, 0.2);
      background: rgba(255, 255, 255, 0.62);
      color: #214a74;
      font-weight: 700;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.45);
    }

    body[data-night="true"] #sportsUpdated {
      border-color: rgba(209, 226, 248, 0.35);
      background: rgba(16, 33, 52, 0.56);
      color: #d3e4f9;
      text-shadow: none;
    }

    .expandable-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 0.98rem 1.15rem;
      transition: background 160ms ease;
    }

    .expandable-header:hover {
      background: rgba(10, 30, 55, 0.04);
    }

    a:focus-visible,
    button:focus-visible,
    input:focus-visible,
    .expandable-header:focus-visible {
      outline: 2px solid rgba(31, 111, 235, 0.75);
      outline-offset: 2px;
      border-radius: 10px;
    }

    .expandable-left {
      display: flex;
      align-items: center;
      gap: 0.58rem;
    }

    .expandable-arrow {
      font-size: 1rem;
      color: var(--text-secondary);
      transition: transform 220ms ease;
      line-height: 1;
    }

    .expandable.open .expandable-arrow {
      transform: rotate(180deg);
    }

    .expandable-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 260ms ease;
    }

    .expandable.open .expandable-content {
      max-height: 340px;
    }

    #evExpandable.open .expandable-content {
      max-height: 760px;
    }

    #sportsExpandable.open .expandable-content {
      max-height: 980px;
    }

    #sportsExpandable.weekday-mode {
      opacity: 0.97;
    }

    .sports-content-wrap {
      border: 0;
      box-shadow: none;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      border-radius: 0;
      padding-top: 0.1rem;
      display: grid;
      gap: 0.65rem;
    }

    .sports-subtitle {
      font-size: 0.72rem;
      font-weight: 800;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #2b517b;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.45);
    }

    body[data-night="true"] .sports-subtitle {
      color: #d2e3f9;
      text-shadow: none;
    }

    .sports-list {
      display: grid;
      gap: 0.52rem;
    }

    .sports-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 0.55rem;
      align-items: center;
      border: 1px solid rgba(14, 33, 54, 0.09);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.72);
      padding: 0.58rem 0.7rem;
    }

    .sports-main {
      min-width: 0;
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 0.72rem;
    }

    .sports-matchup-row {
      display: inline-flex;
      align-items: center;
      gap: 0.62rem;
      min-width: 0;
      max-width: 100%;
    }

    .sports-team-icon {
      width: 48px;
      height: 48px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      color: #1f446d;
      font-size: 0.8rem;
      font-weight: 800;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .sports-team-icon img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .sports-matchup {
      font-size: 0.86rem;
      font-weight: 700;
      color: #173a5b;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
    }

    .sports-context {
      display: grid;
      gap: 0.08rem;
      min-width: 0;
      text-align: right;
    }

    .sports-meta {
      font-size: 0.73rem;
      font-weight: 600;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sports-location {
      font-size: 0.71rem;
      font-weight: 600;
      color: #2f5b86;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sports-status {
      font-size: 0.7rem;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      border-radius: 999px;
      padding: 0.22rem 0.48rem;
      border: 1px solid rgba(16, 32, 50, 0.14);
      color: var(--text-secondary);
      background: rgba(16, 32, 50, 0.06);
      white-space: nowrap;
    }

    .sports-status.live {
      color: #9b1c1c;
      border-color: rgba(155, 28, 28, 0.22);
      background: rgba(155, 28, 28, 0.1);
    }

    .sports-status.final {
      color: #225ea6;
      border-color: rgba(34, 94, 166, 0.2);
      background: rgba(34, 94, 166, 0.1);
    }

    .activity-list {
      display: grid;
      gap: 0.5rem;
    }

    .activity-grid {
      display: grid;
      gap: 0.6rem;
    }

    .activity-column {
      display: grid;
      gap: 0.45rem;
      align-content: start;
    }

    .activity-column-title {
      font-size: 0.68rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #2b517b;
    }

    body[data-night="true"] .activity-column-title {
      color: #d2e3f9;
    }

    .activity-link {
      display: grid;
      gap: 0.08rem;
      text-decoration: none;
      border: 1px solid rgba(14, 33, 54, 0.09);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.72);
      padding: 0.56rem 0.66rem;
      color: inherit;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    .activity-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(18, 43, 74, 0.08);
    }

    body.weekend-layout .activity-grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .activity-name {
      font-size: 0.8rem;
      font-weight: 700;
      color: #173a5b;
    }

    .activity-meta {
      font-size: 0.71rem;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .ev-content-wrap {
      border: 0;
      box-shadow: none;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      border-radius: 0;
      padding-top: 0.1rem;
    }

    .ev-toggle-row {
      margin: 0 0 0.6rem auto;
      width: max-content;
    }

    .stations-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.7rem;
      padding: 0 1.15rem 1.15rem;
    }

    .station {
      border: 1px solid rgba(14, 33, 54, 0.09);
      border-radius: 13px;
      background: rgba(255, 255, 255, 0.72);
      padding: 0.84rem;
    }

    .station-name {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 700;
      margin-bottom: 0.45rem;
      text-transform: uppercase;
      letter-spacing: 0.045em;
    }

    .station-stats {
      display: flex;
      gap: 1.15rem;
    }

    .stat {
      display: grid;
      gap: 0.08rem;
      min-width: 48px;
    }

    .stat-value {
      font-size: 1.48rem;
      line-height: 1;
      font-weight: 800;
      color: #133352;
      letter-spacing: -0.015em;
    }

    .stat-label {
      font-size: 0.68rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .loading {
      color: var(--text-muted);
      font-weight: 600;
    }

    @keyframes riseIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 980px) {
      .main-grid {
        grid-template-columns: 1fr;
      }

      body.weekend-layout .activity-grid {
        grid-template-columns: 1fr;
      }

      .hero-right {
        margin-left: 0;
        width: 100%;
        justify-content: space-between;
      }

      .hero-weather {
        min-width: 0;
        width: 100%;
      }

      .quick-nav {
        margin-top: 0.45rem;
      }

      .weather-stats {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      body {
        padding: 1rem;
      }

      .hero,
      .card,
      .expandable {
        border-radius: 16px;
        backdrop-filter: blur(18px) saturate(135%);
        -webkit-backdrop-filter: blur(18px) saturate(135%);
        box-shadow:
          0 18px 36px rgba(8, 24, 46, 0.18),
          inset 0 1px 0 rgba(255, 255, 255, 0.72),
          inset 0 -12px 24px rgba(255, 255, 255, 0.07),
          inset 0 0 0 1px rgba(255, 255, 255, 0.28);
      }

      .hero {
        padding: 1rem;
      }

      .card {
        padding: 0.95rem;
      }

      #menuContent,
      .stations-grid {
        grid-template-columns: 1fr;
      }

      .weather-stats {
        grid-template-columns: 1fr;
      }

      .weather-stat {
        min-height: 58px;
      }

      .departure-row {
        grid-template-columns: 1fr;
        gap: 0.3rem;
      }

      .sports-row {
        grid-template-columns: 1fr;
        gap: 0.32rem;
      }

      .sports-main {
        grid-template-columns: 1fr;
        gap: 0.26rem;
      }

      .sports-context {
        text-align: left;
      }

      .sports-status {
        justify-self: start;
      }

      .departure-time {
        font-size: 0.76rem;
      }

      .plug-list {
        grid-template-columns: 1fr;
      }

      .sun {
        width: 80px;
        height: 80px;
      }

      .moon {
        width: 58px;
        height: 58px;
      }
    }
  </style>
</head>

<body>
  <div class="weather-bg">
    <div class="ai-bg" id="aiBackground"></div>
    <div class="sun"></div>
    <div class="moon"></div>
    <div class="stars">
      <div class="star" style="top:5%;left:10%;animation-delay:0s;"></div>
      <div class="star" style="top:12%;left:25%;animation-delay:0.5s;"></div>
      <div class="star" style="top:8%;left:45%;animation-delay:1s;"></div>
      <div class="star" style="top:15%;left:65%;animation-delay:0.3s;"></div>
      <div class="star" style="top:5%;left:80%;animation-delay:0.8s;"></div>
      <div class="star" style="top:20%;left:90%;animation-delay:1.2s;"></div>
      <div class="star" style="top:25%;left:5%;animation-delay:0.6s;"></div>
      <div class="star" style="top:18%;left:35%;animation-delay:1.5s;"></div>
      <div class="star" style="top:3%;left:55%;animation-delay:2s;"></div>
      <div class="star" style="top:22%;left:72%;animation-delay:1.8s;"></div>
    </div>
    <div class="cloud-layer">
      <div class="atmospheric-cloud cloud-1"></div>
      <div class="atmospheric-cloud cloud-2"></div>
      <div class="atmospheric-cloud cloud-3"></div>
      <div class="atmospheric-cloud cloud-4"></div>
    </div>
    <div class="rain-container"></div>
    <div class="snow-container"></div>
  </div>

  <div class="dashboard">
    <header class="hero">
      <div class="hero-left">
        <div class="greeting" id="greeting">Good evening, Charles</div>
        <div id="clock">--:--</div>
        <div class="quick-nav">
          <a class="quick-link" href="#commuteSection">Commute</a>
          <a class="quick-link" href="#sportsExpandable">Sports</a>
          <a class="quick-link" href="#menuSection">Lifestyle</a>
          <a class="quick-link" href="about.html">About</a>
        </div>
        <div class="temp-toggle-inline" id="tempToggleControl">
          <span class="temp-toggle-label">Temp</span>
          <span class="temp-unit" id="tempUnitCLabel">&deg;C</span>
          <label class="toggle">
            <input type="checkbox" id="tempUnitToggle" aria-label="Toggle Fahrenheit temperature" />
            <span class="toggle-slider"></span>
          </label>
          <span class="temp-unit" id="tempUnitFLabel">&deg;F</span>
        </div>
      </div>
      <div id="date">--</div>
      <div class="hero-right">
        <div class="hero-weather" id="heroWeather">
          <div class="weather-main">
            <div class="weather-icon">WX</div>
            <div>
              <div class="weather-temp loading">--&deg;C</div>
              <div class="weather-condition">Loading...</div>
            </div>
          </div>
          <div class="weather-stats">
            <div class="weather-stat">
              <div class="weather-stat-value">--</div>
              <div class="weather-stat-label">Feels like</div>
            </div>
            <div class="weather-stat">
              <div class="weather-stat-value">--</div>
              <div class="weather-stat-label">Humidity</div>
            </div>
            <div class="weather-stat">
              <div class="weather-stat-value">--</div>
              <div class="weather-stat-label">Wind</div>
            </div>
          </div>
          <div class="weather-meta">Last updated -- - <a href="https://open-meteo.com/" target="_blank" rel="noopener noreferrer">Weather data by Open-Meteo.com</a></div>
        </div>
        <div class="brand-pill">Cambridge HQ</div>
      </div>
    </header>

    <div class="main-grid">
      <section class="stack" id="commuteSection">
        <div class="stack-label">Commute</div>
        <div class="card">
          <div class="card-header">
            <div class="card-icon icon-transit">RL</div>
            <span class="card-title">Alewife Red Line Departures</span>
          </div>
          <div class="departures-list" id="redlineDepartures">
            <div class="departure-empty loading">Loading departures...</div>
          </div>
          <div class="card-note" id="redlineUpdated">Updated --</div>
        </div>

        <div class="expandable" id="evExpandable">
          <div class="expandable-header" onclick="toggleEvPanel()" tabindex="0" role="button" aria-expanded="false">
            <div class="expandable-left">
              <div class="card-icon icon-charge">CP</div>
              <span class="expandable-title">Garage B EV Charger Status</span>
            </div>
            <span class="expandable-arrow">v</span>
          </div>
          <div class="expandable-content">
            <div class="card ev-content-wrap">
              <div class="toggle-row ev-toggle-row">
                <span class="toggle-label">Notify until 5 PM</span>
                <label class="toggle">
                  <input type="checkbox" id="chargepointNotifyToggle" />
                  <span class="toggle-slider"></span>
                </label>
              </div>
              <div class="charger-summary" id="chargepointSummary">Available --</div>
              <div class="charger-grid" id="chargepointList">
                <div class="departure-empty loading">Loading chargers...</div>
              </div>
              <div class="card-note" id="chargepointUpdated">Updated --</div>
            </div>
          </div>
        </div>

        <div class="expandable" id="bikeExpandable">
          <div class="expandable-header" onclick="toggleBikes()" tabindex="0" role="button" aria-expanded="false">
            <div class="expandable-left">
              <div class="card-icon icon-bike">BK</div>
              <span class="expandable-title">Bluebikes Stations</span>
            </div>
            <span class="expandable-arrow">v</span>
          </div>
          <div class="expandable-content">
            <div class="stations-grid">
              <div class="station">
                <div class="station-name">Home Station</div>
                <div class="station-stats" id="homeStatus">
                  <div class="stat"><span class="stat-value loading">--</span><span class="stat-label">Bikes</span></div>
                  <div class="stat"><span class="stat-value loading">--</span><span class="stat-label">Docks</span></div>
                </div>
              </div>
              <div class="station">
                <div class="station-name">Work Station</div>
                <div class="station-stats" id="workStatus">
                  <div class="stat"><span class="stat-value loading">--</span><span class="stat-label">Bikes</span></div>
                  <div class="stat"><span class="stat-value loading">--</span><span class="stat-label">Docks</span></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="stack" id="menuSection">
        <div class="stack-label">Lifestyle</div>
        <div class="expandable" id="sportsExpandable">
          <div class="expandable-header" onclick="toggleSportsPanel()" tabindex="0" role="button" aria-expanded="false">
            <div class="expandable-left">
              <div class="card-icon icon-sports">SP</div>
              <span class="expandable-title">Boston Sports</span>
            </div>
            <span class="expandable-arrow">v</span>
          </div>
          <div class="expandable-content">
            <div class="card sports-content-wrap">
              <div class="sports-subtitle" id="sportsWindowLabel">This week</div>
              <div class="sports-list" id="sportsList">
                <div class="departure-empty loading">Loading Boston games...</div>
              </div>
              <div class="sports-subtitle">Local activities this week</div>
              <div class="activity-list" id="activityList">
                <div class="departure-empty loading">Loading activity links...</div>
              </div>
              <div class="card-note" id="sportsUpdated">Updated --</div>
            </div>
          </div>
        </div>

        <div class="card" id="menuCard">
          <div class="card-header">
            <div class="card-icon icon-menu">MN</div>
            <span class="card-title">Today's Menu</span>
            <span id="menuDay"></span>
            <button class="menu-collapse-btn" id="menuCollapseBtn" type="button" aria-label="Toggle menu panel" aria-controls="menuPanelBody" aria-expanded="true" onclick="toggleMenuPanel()">v</button>
          </div>
          <div class="menu-panel-body" id="menuPanelBody">
            <div class="menu-image-panel">
              <div class="menu-image-header">
                <div>
                  <div class="menu-image-title">Daily Highlights</div>
                  <div class="menu-action-name" id="menuActionName">Loading...</div>
                </div>
              </div>
              <div class="menu-image-status" id="menuImageStatus">No image configured.</div>
              <div class="menu-highlight-grid" id="menuHighlightsGrid"></div>
            </div>
            <div id="menuContent"><span class="loading">Loading...</span></div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const HOME_STATION_ID = "bd3d4824-7203-4edc-a314-cea2b413e886";
    const WORK_STATION_ID = "8347c34d-68df-404b-ac58-7a387cc3ce4b";
    const LAT = 42.39;
    const LON = -71.14;
    const MBTA_STOP_ID = "place-alfcl";
    const MBTA_ROUTE_ID = "Red";
    const MBTA_DEPARTURE_DIRECTION = "0";
    const MBTA_DEPARTURE_LIMIT = 6;
    const CHARGEPOINT_ENDPOINT = "https://mc.chargepoint.com/map-prod/v3/station";
    const CHARGEPOINT_LOCATIONS = [
      { deviceId: "1850061", name: "BULFINCH GARAGE B EV6" },
      { deviceId: "1850031", name: "BULFINCH GARAGE B EV1" },
      { deviceId: "1850041", name: "BULFINCH GARAGE B EV4" },
      { deviceId: "1850011", name: "BULFINCH GARAGE B EV5" },
      { deviceId: "1850021", name: "BULFINCH GARAGE B EV2" },
      { deviceId: "1850001", name: "BULFINCH GARAGE B EV3" }
    ];
    const CHARGEPOINT_PORTS_PER_STATION = 2;
    const CHARGEPOINT_POLL_MS = 30000;
    const CHARGEPOINT_NOTIFY_AFTER_MS = 60000;
    const CHARGEPOINT_NOTIFY_CUTOFF_HOUR = 17;
    const CHARGEPOINT_NOTIFY_STORAGE_KEY = "chargepointNotifyUntil";
    const CHARGEPOINT_NOTIFY_ENABLED_KEY = "chargepointNotifyEnabled";
    const EV_PANEL_OPEN_KEY = "evPanelOpen";
    const WEATHER_CACHE_KEY = "cachedWeatherMain";
    const WEATHER_CACHE_TS_KEY = "cachedWeatherMainTs";
    const WEATHER_CACHE_PAYLOAD_KEY = "cachedWeatherPayloadV2";
    const WEATHER_CACHE_UPDATED_KEY = "cachedWeatherLastUpdatedV2";
    const WEATHER_REFRESH_MIN_MS = 15 * 60 * 1000;
    const WEATHER_REFRESH_MAX_MS = 30 * 60 * 1000;
    const TEMP_UNIT_STORAGE_KEY = "temperatureUnit";
    const SPORTS_LOOKAHEAD_DAYS = 7;
    const SPORTS_REFRESH_MS = 30 * 60 * 1000;
    const EVENTS_PER_CITY = 6;
    const EVENTS_FETCH_LIMIT = 40;
    const LOCAL_EVENTS_MAX_LOOKAHEAD_DAYS = 30;
    const MENU_PANEL_COLLAPSED_KEY = "menuPanelCollapsed";
    const MENU_ACTION_IMAGE_URL = "assets/menu-action-placeholder.png";
    const WEEKEND_NO_MENU_IMAGE_URL = "assets/menu-weekend-no-items-boston-vibe.png";
    const BOSTON_TEAM_NAMES = new Set([
      "Boston Celtics",
      "Boston Bruins",
      "Boston Red Sox",
      "New England Patriots"
    ]);
    const BOSTON_SPORTS_LEAGUES = [
      { sport: "basketball", league: "nba", label: "NBA" },
      { sport: "hockey", league: "nhl", label: "NHL" },
      { sport: "baseball", league: "mlb", label: "MLB" },
      { sport: "football", league: "nfl", label: "NFL" }
    ];
    const CITY_EVENT_FEEDS = [
      {
        source: "Boston.gov",
        rssUrl: "https://www.boston.gov/rss/events"
      },
      {
        source: "CambridgeUSA",
        rssUrl: "https://www.cambridgeusa.org/events/rss"
      }
    ];
    const RECURRING_EVENT_PATTERNS = [
      /\bweekly\b/i,
      /\bmonthly\b/i,
      /\bevery (monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/i,
      /\bopen hours?\b/i,
      /\bdrop-?in\b/i,
      /\bstory ?time\b/i,
      /\bongoing\b/i,
      /\brecurring\b/i,
      /^hike boston:/i
    ];
    const LOCAL_ACTIVITY_LINKS = [
      {
        name: "The Boston Calendar",
        meta: "Curated city events, concerts, classes, and festivals",
        url: "https://www.thebostoncalendar.com/"
      },
      {
        name: "Cambridge Office for Tourism",
        meta: "This week around Harvard Square, Kendall, and beyond",
        url: "https://www.cambridgeusa.org/events/"
      },
      {
        name: "Cambridge Arts Calendar",
        meta: "Talks, exhibits, performances, and neighborhood arts",
        url: "https://www.cambridgema.gov/arts/Calendar"
      },
      {
        name: "Boston.gov Events",
        meta: "Official city events and community programming",
        url: "https://www.boston.gov/events"
      }
    ];
    const BACKGROUND_IMAGES = {
      "normal-day": "assets/backgrounds/app-bg-normal-day.jpg",
      "normal-sunset": "assets/backgrounds/app-bg-normal-sunset.png",
      "normal-night": "assets/backgrounds/app-bg-normal-night.png",
      "cloudy-day": "assets/backgrounds/app-bg-cloudy-day.png",
      "cloudy-sunset": "assets/backgrounds/app-bg-cloudy-sunset.png",
      "cloudy-night": "assets/backgrounds/app-bg-cloudy-night.png",
      "rain-day": "assets/backgrounds/app-bg-rain-day.png",
      "rain-sunset": "assets/backgrounds/app-bg-rain-sunset.png",
      "rain-night": "assets/backgrounds/app-bg-rain-night.png",
      "snow-day": "assets/backgrounds/app-bg-snow-day.png",
      "snow-sunset": "assets/backgrounds/app-bg-snow-sunset.png",
      "snow-night": "assets/backgrounds/app-bg-snow-night.png"
    };
    function loadFreshCachedWeatherMain() {
      const cached = localStorage.getItem(WEATHER_CACHE_KEY) || "";
      const ts = Number(localStorage.getItem(WEATHER_CACHE_TS_KEY) || 0);
      if (!cached || !ts) return "";
      return cached;
    }

    function loadCachedWeatherPayload() {
      const raw = localStorage.getItem(WEATHER_CACHE_PAYLOAD_KEY);
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.weather || !parsed.main) return null;
        return parsed;
      } catch (err) {
        return null;
      }
    }

    function normalizeWeatherCodeLabel(code) {
      const codeNum = Number(code);
      if (codeNum === 0) return { main: "Clear", label: "Clear sky" };
      if (codeNum === 1) return { main: "Clouds", label: "Mainly clear" };
      if (codeNum === 2) return { main: "Clouds", label: "Partly cloudy" };
      if (codeNum === 3) return { main: "Clouds", label: "Overcast" };
      if (codeNum === 45 || codeNum === 48) return { main: "Fog", label: "Fog" };
      if (codeNum >= 51 && codeNum <= 57) return { main: "Drizzle", label: "Drizzle" };
      if ((codeNum >= 61 && codeNum <= 67) || (codeNum >= 80 && codeNum <= 82)) return { main: "Rain", label: "Rain" };
      if ((codeNum >= 71 && codeNum <= 77) || (codeNum >= 85 && codeNum <= 86)) return { main: "Snow", label: "Snow" };
      if (codeNum >= 95 && codeNum <= 99) return { main: "Thunderstorm", label: "Thunderstorm" };
      return { main: "Clouds", label: "Cloudy" };
    }

    function normalizeOpenMeteoCurrent(data) {
      const current = data && data.current ? data.current : null;
      if (!current) return null;
      const weather = normalizeWeatherCodeLabel(current.weather_code);
      return {
        source: "open-meteo",
        weather: [{ main: weather.main, description: weather.label, code: Number(current.weather_code) }],
        main: {
          temp: Number(current.temperature_2m),
          feels_like: Number(current.apparent_temperature),
          humidity: Number(current.relative_humidity_2m),
          pressure: Number(current.pressure_msl)
        },
        wind: {
          speed: Number(current.wind_speed_10m),
          gust: Number(current.wind_gusts_10m)
        },
        clouds: {
          all: Number(current.cloud_cover)
        },
        precipitation: Number(current.precipitation),
        uv_index: Number(current.uv_index),
        is_day: Number(current.is_day) === 1,
        observedAtMs: Number(current.time) * 1000,
        timezone: data.timezone || "local",
        daily: data.daily || null,
        lastUpdatedMs: Date.now()
      };
    }

    const cachedWeatherPayload = loadCachedWeatherPayload();
    let currentWeatherMain = (cachedWeatherPayload && cachedWeatherPayload.weather && cachedWeatherPayload.weather[0] && cachedWeatherPayload.weather[0].main)
      || loadFreshCachedWeatherMain();
    let weatherSceneSyncKey = "";
    let currentBackgroundKey = "";
    let weatherSceneReady = !!currentWeatherMain;
    let latestWeatherPayload = cachedWeatherPayload;
    let temperatureUnit = localStorage.getItem(TEMP_UNIT_STORAGE_KEY) === "F" ? "F" : "C";
    let latestRealEventsByCity = { cambridge: [], boston: [] };
    const celestialPlacementCache = new Map();
    let celestialPlacementRequestId = 0;

    function toggleBikes() {
      const expandable = document.getElementById('bikeExpandable');
      expandable.classList.toggle('open');
      const header = expandable.querySelector('.expandable-header');
      if (header) {
        header.setAttribute('aria-expanded', expandable.classList.contains('open') ? 'true' : 'false');
      }
    }

    function setEvPanelOpenState(isOpen) {
      const expandable = document.getElementById("evExpandable");
      if (!expandable) return;
      expandable.classList.toggle("open", isOpen);
      const header = expandable.querySelector(".expandable-header");
      if (header) {
        header.setAttribute("aria-expanded", isOpen ? "true" : "false");
      }
      localStorage.setItem(EV_PANEL_OPEN_KEY, isOpen ? "true" : "false");
    }

    function toggleEvPanel() {
      const expandable = document.getElementById("evExpandable");
      if (!expandable) return;
      setEvPanelOpenState(!expandable.classList.contains("open"));
    }

    function isWeekendDay(date = new Date()) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    function applyWeekendLayoutState(date = new Date()) {
      document.body.classList.toggle("weekend-layout", isWeekendDay(date));
    }

    function setSportsPanelExpanded(isOpen) {
      const expandable = document.getElementById("sportsExpandable");
      if (!expandable) return;
      expandable.classList.toggle("open", isOpen);
      const header = expandable.querySelector(".expandable-header");
      if (header) {
        header.setAttribute("aria-expanded", isOpen ? "true" : "false");
      }
    }

    function toggleSportsPanel() {
      const expandable = document.getElementById("sportsExpandable");
      if (!expandable) return;
      setSportsPanelExpanded(!expandable.classList.contains("open"));
    }

    function setMenuPanelCollapsedState(isCollapsed) {
      const card = document.getElementById("menuCard");
      const btn = document.getElementById("menuCollapseBtn");
      if (!card || !btn) return;
      card.classList.toggle("menu-collapsed", isCollapsed);
      btn.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
      localStorage.setItem(MENU_PANEL_COLLAPSED_KEY, isCollapsed ? "true" : "false");
    }

    function toggleMenuPanel() {
      const card = document.getElementById("menuCard");
      if (!card) return;
      setMenuPanelCollapsedState(!card.classList.contains("menu-collapsed"));
    }

    function placeSportsPanelByDay(date = new Date()) {
      const isWeekend = isWeekendDay(date);
      const section = document.getElementById("menuSection");
      const sports = document.getElementById("sportsExpandable");
      const menuCard = document.getElementById("menuCard");
      if (!section || !sports || !menuCard) return;

      if (isWeekend) {
        section.insertBefore(sports, menuCard);
        sports.classList.remove("weekday-mode");
        setSportsPanelExpanded(true);
      } else {
        section.appendChild(sports);
        sports.classList.add("weekday-mode");
        setSportsPanelExpanded(false);
      }
    }

    function formatDateAsRangeLabel(start, end) {
      const options = { month: "short", day: "numeric" };
      const startLabel = start.toLocaleDateString([], options);
      const endLabel = end.toLocaleDateString([], options);
      return `${startLabel} - ${endLabel}`;
    }

    function isCambridgeActivity(item) {
      const sourceText = String(item.source || item.name || "").toLowerCase();
      return sourceText.includes("cambridge");
    }

    function isBostonActivity(item) {
      const sourceText = String(item.source || item.name || "").toLowerCase();
      return sourceText.includes("boston");
    }

    function normalizeEventTitle(title) {
      return String(title || "")
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function isLikelyRecurringEvent(item, titleCounts) {
      const title = String(item.title || item.name || "");
      const desc = String(item.description || item.meta || "");
      const normalized = normalizeEventTitle(title);
      const repeatedTitle = (titleCounts.get(normalized) || 0) > 1;
      const text = `${title} ${desc}`;
      const patternHit = RECURRING_EVENT_PATTERNS.some(pattern => pattern.test(text));
      return repeatedTitle || patternHit;
    }

    function isHardExcludedEvent(item) {
      const title = String(item.title || item.name || "");
      return /^hike boston:/i.test(title) || /\bhike boston\b/i.test(title);
    }

    function parseActivityTimestamp(value) {
      if (!value) return NaN;
      const ts = new Date(value).getTime();
      return Number.isNaN(ts) ? NaN : ts;
    }

    function inferEventDateFromText(item) {
      const text = `${item?.title || ""} ${item?.description || ""}`;
      const patterns = [
        /\b(?:mon|tue|wed|thu|fri|sat|sun)\w*,\s*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2})(?:,\s*(\d{4}))?,\s*(\d{1,2}):(\d{2})\s*(am|pm)\b/i,
        /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2})(?:,\s*(\d{4}))?(?:,\s*(\d{1,2}):(\d{2})\s*(am|pm))?\b/i,
        /\b(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?(?:\s+(\d{1,2}):(\d{2})\s*(am|pm)?)?\b/i
      ];

      let match = null;
      let matchedPattern = -1;
      for (let i = 0; i < patterns.length; i += 1) {
        match = text.match(patterns[i]);
        if (match) {
          matchedPattern = i;
          break;
        }
      }
      if (!match) return NaN;

      const monthMap = {
        jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5,
        jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11
      };
      let month = NaN;
      let day = NaN;
      let year = new Date().getFullYear();
      let hour = 12;
      let minute = 0;
      let ampm = "";

      if (matchedPattern === 0 || matchedPattern === 1) {
        month = monthMap[String(match[1]).slice(0, 3).toLowerCase()];
        day = Number(match[2]);
        year = Number(match[3] || year);
        if (match[4] && match[5] && match[6]) {
          hour = Number(match[4]);
          minute = Number(match[5]);
          ampm = String(match[6]).toLowerCase();
        }
      } else {
        month = Number(match[1]) - 1;
        day = Number(match[2]);
        if (match[3]) {
          const rawYear = Number(match[3]);
          year = rawYear < 100 ? 2000 + rawYear : rawYear;
        }
        if (match[4] && match[5]) {
          hour = Number(match[4]);
          minute = Number(match[5]);
          ampm = String(match[6] || "").toLowerCase();
        }
      }

      if (!Number.isFinite(month) || month < 0 || month > 11 || !Number.isFinite(day) || day < 1 || day > 31) {
        return NaN;
      }

      if (ampm === "pm" && hour !== 12) hour += 12;
      if (ampm === "am" && hour === 12) hour = 0;

      let candidate = new Date(year, month, day, hour, minute, 0, 0);
      if (!match[3] && candidate.getTime() < Date.now()) {
        // If year is absent and this date already passed, interpret as next year.
        candidate = new Date(year + 1, month, day, hour, minute, 0, 0);
      }
      const ts = candidate.getTime();
      return Number.isNaN(ts) ? NaN : ts;
    }

    function getActivityDateInfo(item) {
      const strongCandidates = [
        item?.eventDate,
        item?.startDate
      ];
      for (const value of strongCandidates) {
        const ts = parseActivityTimestamp(value);
        if (!Number.isNaN(ts)) return { timestamp: ts, confidence: "high" };
      }
      const inferredTs = inferEventDateFromText(item);
      if (!Number.isNaN(inferredTs)) return { timestamp: inferredTs, confidence: "medium" };
      const publishedTs = parseActivityTimestamp(item?.publishedAt);
      if (!Number.isNaN(publishedTs)) return { timestamp: publishedTs, confidence: "low" };
      return { timestamp: NaN, confidence: "none" };
    }

    function getActivityTimestamp(item) {
      return getActivityDateInfo(item).timestamp;
    }

    function filterEventsInTimeWindow(events, startDate, endDate) {
      const nowMs = Date.now();
      const cappedEnd = new Date(startDate.getTime());
      cappedEnd.setDate(cappedEnd.getDate() + LOCAL_EVENTS_MAX_LOOKAHEAD_DAYS);
      const upperMs = cappedEnd.getTime();
      return events.filter(item => {
        const dateInfo = getActivityDateInfo(item);
        const ts = dateInfo.timestamp;
        if (Number.isNaN(ts)) return false;
        if (dateInfo.confidence === "high" || dateInfo.confidence === "medium") {
          return ts >= nowMs && ts <= upperMs;
        }
        // For low-confidence dates (usually publish timestamp), keep only if still upcoming.
        return ts >= nowMs && ts <= upperMs;
      });
    }

    function dedupeEvents(events) {
      const seen = new Set();
      const output = [];
      for (const item of events) {
        const titleKey = normalizeEventTitle(item.title || item.name || "");
        const dateKey = String(item.publishedAt || "").slice(0, 16);
        const linkKey = String(item.link || item.url || "")
          .toLowerCase()
          .replace(/^https?:\/\//, "")
          .replace(/\/+$/, "");
        const compound = `${titleKey}|${dateKey}`;
        const key = linkKey || compound;
        if (!key) continue;
        if (seen.has(key)) continue;
        seen.add(key);
        output.push(item);
      }
      return output;
    }

    function renderActivityColumns(cambridgeItems, bostonItems) {
      const list = document.getElementById("activityList");
      if (!list) return;
      const makeCard = (item, sourceFallback = "") => `
        <a class="activity-link" href="${escapeHtml(item.link || item.url || "#")}" target="_blank" rel="noreferrer noopener">
          <div class="activity-name">${escapeHtml(item.title || item.name || "Local event")}</div>
          <div class="activity-meta">${escapeHtml(item.meta || item.source || sourceFallback)}</div>
        </a>
      `;
      const cambridgeMarkup = cambridgeItems.length
        ? cambridgeItems.map(item => makeCard(item, "Cambridge")).join("")
        : `<div class="departure-empty">No Cambridge events found right now.</div>`;
      const bostonMarkup = bostonItems.length
        ? bostonItems.map(item => makeCard(item, "Boston")).join("")
        : `<div class="departure-empty">No Boston events found right now.</div>`;
      list.innerHTML = `
        <div class="activity-grid">
          <div class="activity-column">
            <div class="activity-column-title">Cambridge</div>
            ${cambridgeMarkup}
          </div>
          <div class="activity-column">
            <div class="activity-column-title">Boston</div>
            ${bostonMarkup}
          </div>
        </div>
      `;
    }

    function formatEspnDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}${month}${day}`;
    }

    function formatSportsSchedule(isoDate) {
      const gameDate = new Date(isoDate);
      return gameDate.toLocaleString([], {
        weekday: "short",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit"
      });
    }

    function resolveEspnTeamLogo(league, sport, team) {
      const fromPayload = team?.logos?.[0]?.href || "";
      if (fromPayload && /^https:\/\//i.test(fromPayload)) return fromPayload;
      const leagueKey = String(league || "").toLowerCase().trim();
      const abbr = String(team?.abbreviation || "")
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "");
      if (abbr && leagueKey) {
        return `https://a.espncdn.com/i/teamlogos/${leagueKey}/500/${abbr}.png`;
      }
      const teamId = String(team?.id || "").trim();
      if (teamId && leagueKey) {
        return `https://a.espncdn.com/i/teamlogos/${leagueKey}/500/${teamId}.png`;
      }
      const sportKey = String(sport || "").toLowerCase().trim();
      if (teamId && sportKey) {
        return `https://a.espncdn.com/i/teamlogos/${sportKey}/500/${teamId}.png`;
      }
      return "";
    }

    function buildSportsStatus(statusType, statusDetail) {
      const state = String(statusType?.state || "").toLowerCase();
      if (state === "in") {
        return { text: statusDetail || "Live", className: "live" };
      }
      if (state === "post") {
        return { text: "Final", className: "final" };
      }
      return { text: "Upcoming", className: "" };
    }

    function formatVenueLocation(competition) {
      const venue = competition?.venue || {};
      const venueName = venue.fullName || venue.name || "";
      const city = venue.address?.city || "";
      const state = venue.address?.state || venue.address?.country || "";
      const cityState = [city, state].filter(Boolean).join(", ");
      if (venueName && cityState) return `${venueName} (${cityState})`;
      if (venueName) return venueName;
      if (cityState) return cityState;
      return "Venue TBD";
    }

    async function fetchLeagueBostonGames(config, startDate, endDate) {
      const dates = `${formatEspnDate(startDate)}-${formatEspnDate(endDate)}`;
      const url = `https://site.api.espn.com/apis/site/v2/sports/${config.sport}/${config.league}/scoreboard?dates=${dates}`;
      const response = await fetch(url);
      const payload = await response.json();
      const events = Array.isArray(payload.events) ? payload.events : [];
      return events
        .map(event => {
          const competition = event.competitions?.[0];
          const competitors = competition?.competitors || [];
          const bostonCompetitor = competitors.find(entry => BOSTON_TEAM_NAMES.has(entry.team?.displayName));
          if (!bostonCompetitor) return null;
          const opponent = competitors.find(entry => entry !== bostonCompetitor);
          const statusType = competition?.status?.type || event.status?.type || {};
          const statusDetail = competition?.status?.type?.shortDetail || event.status?.type?.shortDetail || "";
          const status = buildSportsStatus(statusType, statusDetail);
          const scheduled = formatSportsSchedule(event.date);
          const location = formatVenueLocation(competition);
          const isFinal = status.className === "final";
          const bostonName = bostonCompetitor.team?.shortDisplayName || "Boston";
          const opponentName = opponent?.team?.shortDisplayName || "Opponent";
          const bostonLogo = resolveEspnTeamLogo(config.league, config.sport, bostonCompetitor.team);
          const opponentLogo = resolveEspnTeamLogo(config.league, config.sport, opponent?.team);
          const bostonAbbrev = bostonCompetitor.team?.abbreviation || "BOS";
          const opponentAbbrev = opponent?.team?.abbreviation || "OPP";
          const matchup = `${bostonName} vs ${opponentName}`;
          const meta = isFinal
            ? `${config.label} | ${bostonCompetitor.score || 0}-${opponent?.score || 0}`
            : `${config.label} | ${scheduled}`;
          return {
            id: event.id,
            date: event.date,
            matchup,
            bostonLogo,
            opponentLogo,
            bostonAbbrev,
            opponentAbbrev,
            meta,
            location,
            statusText: status.text,
            statusClass: status.className
          };
        })
        .filter(Boolean);
    }

    function renderSportsGames(games, startDate, endDate) {
      const list = document.getElementById("sportsList");
      const windowLabel = document.getElementById("sportsWindowLabel");
      if (!list || !windowLabel) return;
      windowLabel.textContent = `Boston games (${formatDateAsRangeLabel(startDate, endDate)})`;
      if (!games.length) {
        list.innerHTML = `<div class="departure-empty">No Boston major-league games scheduled in this window.</div>`;
        return;
      }
      list.innerHTML = games
        .slice(0, 12)
        .map(game => `
          <div class="sports-row">
            <div class="sports-main">
              <div class="sports-matchup-row">
                <span class="sports-team-icon">${game.bostonLogo ? `<img src="${escapeHtml(game.bostonLogo)}" alt="${escapeHtml(game.bostonAbbrev)} logo" loading="lazy" data-fallback="${escapeHtml(game.bostonAbbrev)}" onerror="this.replaceWith(document.createTextNode(this.dataset.fallback || 'TEAM'))">` : escapeHtml(game.bostonAbbrev)}</span>
                <div class="sports-matchup">${escapeHtml(game.matchup)}</div>
                <span class="sports-team-icon">${game.opponentLogo ? `<img src="${escapeHtml(game.opponentLogo)}" alt="${escapeHtml(game.opponentAbbrev)} logo" loading="lazy" data-fallback="${escapeHtml(game.opponentAbbrev)}" onerror="this.replaceWith(document.createTextNode(this.dataset.fallback || 'TEAM'))">` : escapeHtml(game.opponentAbbrev)}</span>
              </div>
              <div class="sports-context">
                <div class="sports-meta">${escapeHtml(game.meta)}</div>
                <div class="sports-location">${escapeHtml(game.location || "Venue TBD")}</div>
              </div>
            </div>
            <div class="sports-status ${game.statusClass}">${escapeHtml(game.statusText)}</div>
          </div>
        `)
        .join("");
    }

    function stripHtml(value) {
      return String(value || "").replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
    }

    function formatEventDateLabel(dateValue) {
      const date = new Date(dateValue);
      if (Number.isNaN(date.getTime())) return "Date TBD";
      const nowYear = new Date().getFullYear();
      const options = {
        weekday: "short",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit"
      };
      if (date.getFullYear() !== nowYear) {
        options.year = "numeric";
      }
      return date.toLocaleString([], options);
    }

    function decodePossibleDataUri(value) {
      const raw = String(value || "");
      if (!raw.startsWith("data:")) return raw;
      const commaIndex = raw.indexOf(",");
      if (commaIndex < 0) return raw;
      const meta = raw.slice(0, commaIndex);
      const body = raw.slice(commaIndex + 1);
      if (/;base64/i.test(meta)) {
        try {
          return atob(body);
        } catch (err) {
          return "";
        }
      }
      try {
        return decodeURIComponent(body);
      } catch (err) {
        return body;
      }
    }

    function parseFeedXmlItems(xmlText, feed) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, "text/xml");
      const nodes = Array.from(doc.querySelectorAll("item")).slice(0, EVENTS_FETCH_LIMIT);
      return nodes
        .map(node => {
          const title = node.querySelector("title")?.textContent?.trim() || "";
          const link = node.querySelector("link")?.textContent?.trim() || feed.rssUrl;
          const publishedAt = node.querySelector("pubDate")?.textContent?.trim() || "";
          const description = stripHtml(node.querySelector("description")?.textContent || "");
          if (!title) return null;
          return {
            source: feed.source,
            title,
            link,
            publishedAt,
            eventDate: "",
            startDate: "",
            description
          };
        })
        .filter(Boolean);
    }

    async function fetchRssFeedItemsViaAllOrigins(feed) {
      const endpoint = `https://api.allorigins.win/get?url=${encodeURIComponent(feed.rssUrl)}`;
      const response = await fetch(endpoint);
      const payload = await response.json();
      const xmlRaw = decodePossibleDataUri(payload.contents || "");
      if (!xmlRaw) return [];
      return parseFeedXmlItems(xmlRaw, feed);
    }

    async function fetchRssFeedItems(feed) {
      try {
        const endpoint = `https://api.rss2json.com/v1/api.json?count=${EVENTS_FETCH_LIMIT}&rss_url=${encodeURIComponent(feed.rssUrl)}`;
        const response = await fetch(endpoint);
        const payload = await response.json();
        if (payload.status === "ok" && Array.isArray(payload.items) && payload.items.length) {
          return payload.items.map(item => {
            const title = item.title || "Local event";
            const link = item.link || feed.rssUrl;
            const publishedAt = item.pubDate || item.guid || "";
            const eventDate = item.eventDate || item.event_date || item.date || "";
            const startDate = item.startDate || item.start_date || item.start || "";
            const description = stripHtml(item.description || item.content || "");
            return {
              source: feed.source,
              title,
              link,
              publishedAt,
              eventDate,
              startDate,
              description
            };
          });
        }
      } catch (err) {
      }
      try {
        return await fetchRssFeedItemsViaAllOrigins(feed);
      } catch (err) {
        return [];
      }
    }

    function renderNoEventsState() {
      const list = document.getElementById("activityList");
      if (!list) return;
      list.innerHTML = `
        <div class="activity-grid">
          <div class="activity-column">
            <div class="activity-column-title">Cambridge</div>
            <div class="departure-empty">No Cambridge events available right now.</div>
          </div>
          <div class="activity-column">
            <div class="activity-column-title">Boston</div>
            <div class="departure-empty">No Boston events available right now.</div>
          </div>
        </div>
      `;
    }

    function renderCachedEventsIfAvailable() {
      const cambridgeItems = (latestRealEventsByCity.cambridge || []).slice(0, EVENTS_PER_CITY);
      const bostonItems = (latestRealEventsByCity.boston || []).slice(0, EVENTS_PER_CITY);
      if (!cambridgeItems.length && !bostonItems.length) {
        renderNoEventsState();
        return;
      }
      renderActivityColumns(cambridgeItems, bostonItems);
    }

    function renderLocalActivities(startDate, endDate) {
      renderCachedEventsIfAvailable();
    }

    async function fetchLocalEvents(startDate, endDate) {
      const list = document.getElementById("activityList");
      if (!list) return;
      try {
        const feedItems = await Promise.all(CITY_EVENT_FEEDS.map(feed => fetchRssFeedItems(feed)));
        const allEvents = feedItems
          .flat()
          .sort((a, b) => {
            const at = getActivityTimestamp(a);
            const bt = getActivityTimestamp(b);
            if (Number.isNaN(at) && Number.isNaN(bt)) return 0;
            if (Number.isNaN(at)) return 1;
            if (Number.isNaN(bt)) return -1;
            return at - bt;
          });
        const events = filterEventsInTimeWindow(allEvents, startDate, endDate);

        if (!events.length) {
          renderCachedEventsIfAvailable();
          return;
        }
        const normalized = dedupeEvents(events
          .filter(item => !isHardExcludedEvent(item))
          .map(item => ({
          ...item,
          meta: `${item.source} | ${formatEventDateLabel(getActivityTimestamp(item))}`
          })));
        const titleCounts = new Map();
        normalized.forEach(item => {
          const key = normalizeEventTitle(item.title);
          if (!key) return;
          titleCounts.set(key, (titleCounts.get(key) || 0) + 1);
        });

        const uniqueFirst = normalized
          .filter(item => !isLikelyRecurringEvent(item, titleCounts))
          .concat(normalized.filter(item => isLikelyRecurringEvent(item, titleCounts)));

        let cambridgeItems = uniqueFirst.filter(isCambridgeActivity).slice(0, EVENTS_PER_CITY);
        if (!cambridgeItems.length) {
          cambridgeItems = normalized
            .filter(item => String(item.source || "").toLowerCase().includes("cambridge") || String(item.link || "").toLowerCase().includes("cambridge"))
            .slice(0, EVENTS_PER_CITY);
        }
        let bostonItems = uniqueFirst.filter(item => isBostonActivity(item) && !isLikelyRecurringEvent(item, titleCounts)).slice(0, EVENTS_PER_CITY);
        if (!bostonItems.length) {
          bostonItems = uniqueFirst.filter(isBostonActivity).slice(0, EVENTS_PER_CITY);
        }
        if (!bostonItems.length) {
          bostonItems = normalized
            .filter(item => String(item.source || "").toLowerCase().includes("boston") || String(item.link || "").toLowerCase().includes("boston"))
            .slice(0, EVENTS_PER_CITY);
        }
        latestRealEventsByCity = {
          cambridge: cambridgeItems,
          boston: bostonItems
        };
        renderActivityColumns(cambridgeItems, bostonItems);
      } catch (err) {
        renderCachedEventsIfAvailable();
      }
    }

    async function fetchBostonSports() {
      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(startDate.getDate() + SPORTS_LOOKAHEAD_DAYS);
      renderLocalActivities(startDate, endDate);
      await fetchLocalEvents(startDate, endDate);
      try {
        const gameLists = await Promise.all(
          BOSTON_SPORTS_LEAGUES.map(config => fetchLeagueBostonGames(config, startDate, endDate))
        );
        const games = gameLists.flat().sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
        renderSportsGames(games, startDate, endDate);
      } catch (err) {
        const list = document.getElementById("sportsList");
        if (list) {
          list.innerHTML = `<div class="departure-empty">Unable to load Boston sports right now.</div>`;
        }
      }
      const updated = document.getElementById("sportsUpdated");
      if (updated) {
        updated.textContent = `Updated ${new Date().toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })}`;
      }
    }

    async function refreshSportsPanel() {
      const now = new Date();
      applyWeekendLayoutState(now);
      placeSportsPanelByDay(now);
      await fetchBostonSports();
      setTimeout(refreshSportsPanel, SPORTS_REFRESH_MS);
    }

    function isNight() {
      const hour = new Date().getHours();
      return hour < 6 || hour >= 19;
    }

    function updateGreeting() {
      const hour = new Date().getHours();
      let greeting = "Good evening";
      if (hour < 12) greeting = "Good morning";
      else if (hour < 17) greeting = "Good afternoon";
      document.getElementById("greeting").textContent = `${greeting}, Charles`;
    }

    function updateClock() {
      const now = new Date();
      applyWeekendLayoutState(now);
      updateGreeting();
      document.getElementById("clock").textContent = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      document.getElementById("date").textContent = now.toLocaleDateString([], { weekday: "long", month: "short", day: "numeric" });
      if (weatherSceneReady) {
        const nextSceneKey = `${now.getHours()}:${now.getMinutes()}|${String(currentWeatherMain).toLowerCase()}`;
        if (nextSceneKey !== weatherSceneSyncKey) {
          weatherSceneSyncKey = nextSceneKey;
          updateWeatherScene(currentWeatherMain);
        }
      }
      setTimeout(updateClock, 1000);
    }

    function getTimePhase(now) {
      const hour = now.getHours();
      if (hour < 6 || hour >= 19) return "night";
      if ((hour >= 6 && hour < 8) || (hour >= 17 && hour < 19)) return "sunset";
      return "day";
    }

    function getWeatherBucket(main) {
      if (main.includes("rain") || main.includes("drizzle") || main.includes("thunder")) return "rain";
      if (main.includes("snow")) return "snow";
      if (main.includes("cloud") || main.includes("fog")) return "cloudy";
      return "normal";
    }

    function selectBackgroundVariant(main, now) {
      const weatherBucket = getWeatherBucket(main);
      const phase = getTimePhase(now);
      return `${weatherBucket}-${phase}`;
    }

    function applyAiBackground(main) {
      const variant = selectBackgroundVariant(main, new Date());
      if (variant === currentBackgroundKey) return;
      currentBackgroundKey = variant;
      const target = document.getElementById("aiBackground");
      const src = BACKGROUND_IMAGES[variant] || BACKGROUND_IMAGES["normal-day"];
      target.style.backgroundImage = `url("${src}")`;
      target.style.opacity = variant.endsWith("-night") ? "0.58" : "0.52";
      updateCelestialPlacementForBackground(variant, src);
    }

    function applyCelestialPlacement(side) {
      const sun = document.querySelector(".sun");
      const moon = document.querySelector(".moon");
      if (!sun || !moon) return;
      const useLeft = side === "left";
      sun.style.left = useLeft ? "8%" : "auto";
      sun.style.right = useLeft ? "auto" : "8%";
      moon.style.left = useLeft ? "8%" : "auto";
      moon.style.right = useLeft ? "auto" : "8%";
    }

    function chooseSkySideFromCanvas(ctx, width, height) {
      const patchWidth = Math.max(20, Math.floor(width * 0.2));
      const patchHeight = Math.max(14, Math.floor(height * 0.22));
      const candidates = [
        { side: "left", x: 0, y: 0 },
        { side: "right", x: Math.max(0, width - patchWidth), y: 0 }
      ];
      let best = { side: "right", score: -Infinity };
      for (const candidate of candidates) {
        const imageData = ctx.getImageData(candidate.x, candidate.y, patchWidth, patchHeight).data;
        let score = 0;
        for (let i = 0; i < imageData.length; i += 4) {
          const r = imageData[i];
          const g = imageData[i + 1];
          const b = imageData[i + 2];
          const brightness = (r + g + b) / 3;
          const blueBias = b - Math.max(r, g);
          // Prefer brighter, bluer top-corner regions (likely unobstructed sky).
          score += brightness * 0.85 + blueBias * 1.15;
        }
        if (score > best.score) best = { side: candidate.side, score };
      }
      return best.side;
    }

    function detectSkySideForImage(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            const width = Math.max(80, Math.floor(img.naturalWidth / 8));
            const height = Math.max(60, Math.floor(img.naturalHeight / 8));
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d", { willReadFrequently: true });
            if (!ctx) {
              resolve("right");
              return;
            }
            ctx.drawImage(img, 0, 0, width, height);
            resolve(chooseSkySideFromCanvas(ctx, width, height));
          } catch (err) {
            resolve("right");
          }
        };
        img.onerror = () => resolve("right");
        img.src = src;
      });
    }

    async function updateCelestialPlacementForBackground(variant, src) {
      const cached = celestialPlacementCache.get(variant);
      if (cached) {
        applyCelestialPlacement(cached);
        return;
      }
      const requestId = ++celestialPlacementRequestId;
      const side = await detectSkySideForImage(src);
      celestialPlacementCache.set(variant, side);
      if (requestId === celestialPlacementRequestId) {
        applyCelestialPlacement(side);
      }
    }

    function updateWeatherScene(weatherMain) {
      const main = String(weatherMain || "clear").toLowerCase();
      const night = isNight();
      const root = document.documentElement;
      const body = document.body;
      body.dataset.weather = main;
      body.dataset.night = night ? "true" : "false";
      applyAiBackground(main);

      document.querySelector('.sun').classList.remove('visible');
      document.querySelector('.moon').classList.remove('visible');
      document.querySelector('.stars').classList.remove('visible');
      document.querySelector('.cloud-layer').classList.remove('visible');
      document.querySelector('.rain-container').classList.remove('visible');
      document.querySelector('.snow-container').classList.remove('visible');

      if (main.includes("clear")) {
        if (night) {
          body.style.background = getComputedStyle(root).getPropertyValue("--bg-clear-night");
          document.querySelector('.moon').classList.add('visible');
          document.querySelector('.stars').classList.add('visible');
        } else {
          body.style.background = getComputedStyle(root).getPropertyValue("--bg-clear-day");
          document.querySelector('.sun').classList.add('visible');
        }
      } else if (main.includes("cloud")) {
        body.style.background = getComputedStyle(root).getPropertyValue("--bg-clouds");
        document.querySelector('.cloud-layer').classList.add('visible');
        if (night) {
          document.querySelector('.moon').classList.add('visible');
          document.querySelector('.stars').classList.add('visible');
        }
      } else if (main.includes("rain") || main.includes("drizzle")) {
        body.style.background = getComputedStyle(root).getPropertyValue("--bg-rain");
        document.querySelector('.cloud-layer').classList.add('visible');
        createRain();
      } else if (main.includes("snow")) {
        body.style.background = getComputedStyle(root).getPropertyValue("--bg-snow");
        document.querySelector('.cloud-layer').classList.add('visible');
        createSnow();
      } else if (main.includes("thunder")) {
        body.style.background = getComputedStyle(root).getPropertyValue("--bg-thunder");
        document.querySelector('.cloud-layer').classList.add('visible');
        createRain();
      } else {
        body.style.background = night
          ? getComputedStyle(root).getPropertyValue("--bg-clear-night")
          : getComputedStyle(root).getPropertyValue("--bg-clear-day");
        if (night) {
          document.querySelector('.moon').classList.add('visible');
          document.querySelector('.stars').classList.add('visible');
        } else {
          document.querySelector('.sun').classList.add('visible');
        }
      }
    }

    function createRain() {
      const container = document.querySelector('.rain-container');
      container.innerHTML = '';
      container.classList.add('visible');
      for (let i = 0; i < 60; i++) {
        const drop = document.createElement('div');
        drop.className = 'raindrop';
        drop.style.left = Math.random() * 100 + '%';
        drop.style.animationDuration = (0.4 + Math.random() * 0.2) + 's';
        drop.style.animationDelay = Math.random() * 2 + 's';
        drop.style.opacity = 0.3 + Math.random() * 0.4;
        container.appendChild(drop);
      }
    }

    function createSnow() {
      const container = document.querySelector('.snow-container');
      container.innerHTML = '';
      container.classList.add('visible');
      for (let i = 0; i < 40; i++) {
        const flake = document.createElement('div');
        flake.className = 'snowflake';
        flake.style.left = Math.random() * 100 + '%';
        flake.style.width = flake.style.height = (2 + Math.random() * 3) + 'px';
        flake.style.animationDuration = (5 + Math.random() * 5) + 's';
        flake.style.animationDelay = Math.random() * 5 + 's';
        flake.style.opacity = 0.5 + Math.random() * 0.5;
        container.appendChild(flake);
      }
    }

    async function fetchBikeStatus(stationId, elementId) {
      try {
        const res = await fetch("https://gbfs.bluebikes.com/gbfs/en/station_status.json");
        const data = await res.json();
        const st = data.data.stations.find(s => s.station_id === stationId);
        if (!st) throw new Error("Station not found");
        document.getElementById(elementId).innerHTML = `
          <div class="stat"><span class="stat-value">${st.num_bikes_available}</span><span class="stat-label">Bikes</span></div>
          <div class="stat"><span class="stat-value">${st.num_docks_available}</span><span class="stat-label">Docks</span></div>
        `;
      } catch (err) {
        document.getElementById(elementId).innerHTML = `<div class="stat"><span class="stat-value">--</span><span class="stat-label">Unavailable</span></div>`;
      }
    }

    function refreshBikes() {
      fetchBikeStatus(HOME_STATION_ID, "homeStatus");
      fetchBikeStatus(WORK_STATION_ID, "workStatus");
      setTimeout(refreshBikes, 60000);
    }

    function getEasternDateTimeParts(date = new Date()) {
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hourCycle: "h23"
      });
      const parts = formatter.formatToParts(date);
      const values = {};
      for (const part of parts) {
        if (part.type !== "literal") values[part.type] = part.value;
      }
      return {
        date: `${values.year}-${values.month}-${values.day}`,
        time: `${values.hour}:${values.minute}`
      };
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function setMenuImageStatus(message, isError) {
      const status = document.getElementById("menuImageStatus");
      if (!status) return;
      status.textContent = message;
      status.style.color = isError ? "#9b1c1c" : "var(--text-secondary)";
    }

    function getMenuFallbackImageUrl() {
      if (window.MENU_ACTION_IMAGE_URL) return window.MENU_ACTION_IMAGE_URL;
      if (MENU_ACTION_IMAGE_URL) return MENU_ACTION_IMAGE_URL;
      return "";
    }

    function pickActionMenuItems(entries) {
      const priorities = ["carving", "plant power", "action"];
      const picked = [];
      for (const priority of priorities) {
        const matched = entries.find(([category]) => String(category).toLowerCase() === priority);
        if (matched) {
          picked.push({ category: matched[0], item: matched[1] });
        }
      }
      if (picked.length) return picked;
      const first = entries[0] || [];
      return first[0] && first[1] ? [{ category: first[0], item: first[1] }] : [];
    }

    function normalizeDailyHighlightMeta(dayMeta) {
      if (Array.isArray(dayMeta)) return dayMeta;
      if (dayMeta && typeof dayMeta === "object") return Object.values(dayMeta);
      return [];
    }

    function setMenuHighlightGrid(items) {
      const grid = document.getElementById("menuHighlightsGrid");
      if (!grid) return;
      if (!items.length) {
        grid.innerHTML = `<div class="menu-highlight-empty">No image yet</div>`;
        return;
      }
      grid.innerHTML = items.map(item => {
        const category = escapeHtml(item.category || "Highlight");
        const name = escapeHtml(item.name || "Menu item");
        const imageUrl = escapeHtml(item.imageUrl || getMenuFallbackImageUrl());
        return `
          <div class="menu-highlight-card">
            <div class="menu-highlight-meta">
              <div class="menu-highlight-category">${category}</div>
              <div class="menu-highlight-name">${name}</div>
            </div>
            <div class="menu-highlight-image">
              <img src="${imageUrl}" alt="${category} item photo" loading="lazy" onerror="this.onerror=null; this.src='${escapeHtml(getMenuFallbackImageUrl())}';" />
            </div>
          </div>
        `;
      }).join("");
    }

    function normalizeMenuItemForDisplay(item) {
      const fallback = { name: "Unknown Item", description: "", price: "Market Price", imageUrl: "" };
      if (!item || typeof item !== "object") return fallback;

      // Handle nested object payloads from extraction drift.
      const candidate = (item.name && typeof item.name === "object") ? item.name : item;
      let normalized = {
        name: candidate.name ?? item.name ?? fallback.name,
        description: candidate.description ?? item.description ?? "",
        price: candidate.price ?? item.price ?? fallback.price,
        imageUrl: candidate.imageUrl ?? item.imageUrl ?? item.image ?? ""
      };

      // Handle stringified dict payloads like "{'name': '...', 'description': '', 'price': '$8.95'}".
      const nameString = String(normalized.name || "").trim();
      if (nameString.startsWith("{") && nameString.includes("'name'")) {
        const nameMatch = nameString.match(/'name'\s*:\s*'([^']*)'/);
        const descMatch = nameString.match(/'description'\s*:\s*'([^']*)'/);
        const priceMatch = nameString.match(/'price'\s*:\s*'([^']*)'/);
        normalized = {
          name: (nameMatch && nameMatch[1]) || fallback.name,
          description: (descMatch && descMatch[1]) || "",
          price: (priceMatch && priceMatch[1]) || fallback.price,
          imageUrl: normalized.imageUrl || ""
        };
      }

      return {
        name: String(normalized.name || fallback.name),
        description: String(normalized.description || ""),
        price: String(normalized.price || fallback.price),
        imageUrl: String(normalized.imageUrl || "")
      };
    }

    function updateMenuActionItem(items) {
      const safeItems = Array.isArray(items) ? items.filter(Boolean) : [];
      const label = document.getElementById("menuActionName");
      if (label) {
        if (!safeItems.length) {
          label.textContent = "No menu item";
        } else if (safeItems.length === 1) {
          label.textContent = safeItems[0].name || "Menu highlight";
        } else {
          label.textContent = safeItems.map(it => it.category).filter(Boolean).join(" | ");
        }
      }
      setMenuHighlightGrid(safeItems);
      if (safeItems.length) {
        setMenuImageStatus(`Showing ${safeItems.length} highlight image${safeItems.length > 1 ? "s" : ""}.`, false);
      } else {
        setMenuImageStatus("No menu item available.", true);
      }
    }

    function getTodayNotifyCutoff() {
      const now = new Date();
      return new Date(now.getFullYear(), now.getMonth(), now.getDate(), CHARGEPOINT_NOTIFY_CUTOFF_HOUR, 0, 0, 0);
    }

    function isAfterNotifyCutoff() {
      return Date.now() >= getTodayNotifyCutoff().getTime();
    }

    function loadChargepointNotifyState() {
      const enabled = localStorage.getItem(CHARGEPOINT_NOTIFY_ENABLED_KEY) === "true";
      const until = Number(localStorage.getItem(CHARGEPOINT_NOTIFY_STORAGE_KEY) || 0);
      return { enabled, until };
    }

    function saveChargepointNotifyState(enabled, until) {
      localStorage.setItem(CHARGEPOINT_NOTIFY_ENABLED_KEY, String(enabled));
      localStorage.setItem(CHARGEPOINT_NOTIFY_STORAGE_KEY, String(until));
    }

    function setChargepointNotifyToggle(enabled) {
      const toggle = document.getElementById("chargepointNotifyToggle");
      toggle.checked = enabled;
    }

    async function requestNotificationPermission() {
      if (!("Notification" in window)) return false;
      if (Notification.permission === "granted") return true;
      if (Notification.permission === "denied") return false;
      const result = await Notification.requestPermission();
      return result === "granted";
    }

    function sendChargepointNotification(message) {
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("ChargePoint Update", { body: message });
        return;
      }
      alert(message);
    }

    function normalizeChargepointPorts(payload) {
      const station = payload?.station || payload?.data || payload;
      const stationName = station?.name || station?.name1 || station?.stationName || "";
      const portsInfo = station?.portsInfo?.ports || station?.ports || station?.port_status || station?.portStatus || [];
      const ports = [];
      if (Array.isArray(portsInfo)) {
        for (const port of portsInfo) {
          const statusValue =
            port?.status ||
            port?.port_status ||
            port?.portStatus ||
            port?.state ||
            (port?.available === true ? "AVAILABLE" : port?.available === false ? "IN_USE" : "");
          ports.push({
            status: typeof statusValue === "string" ? statusValue : String(statusValue || "")
          });
        }
      }
      return { stationName, ports };
    }

    function classifyPortStatus(rawStatus) {
      const status = String(rawStatus || "").toLowerCase();
      if (status.includes("available") || status.includes("green")) return "available";
      if (status.includes("in_use") || status.includes("in use") || status.includes("charging") || status.includes("busy") || status.includes("red")) {
        return "in-use";
      }
      return "unavailable";
    }

    function renderChargepointStations(stations) {
      const list = document.getElementById("chargepointList");
      if (!stations.length) {
        list.innerHTML = `<div class="departure-empty">Configure device IDs to load chargers.</div>`;
        return;
      }
      const renderStationCard = station => {
        const ports = station.ports.length ? station.ports : new Array(CHARGEPOINT_PORTS_PER_STATION).fill({ status: "" });
        const displayedPorts = ports.slice(0, CHARGEPOINT_PORTS_PER_STATION);
        while (displayedPorts.length < CHARGEPOINT_PORTS_PER_STATION) {
          displayedPorts.push({ status: "" });
        }
        const portHtml = displayedPorts.map((port, index) => {
          const state = classifyPortStatus(port.status);
          const label = state === "available" ? "Available" : state === "in-use" ? "In Use" : "Unavailable";
          const className = state === "available" ? "plug available" : state === "in-use" ? "plug in-use" : "plug unavailable";
          return `<div class="${className}"><span>Plug ${index + 1}</span><span>${label}</span></div>`;
        }).join("");
        return `
          <div class="charger-station">
            <div class="charger-name">${escapeHtml(station.name || station.stationName || "ChargePoint")}</div>
            <div class="charger-meta">2 plugs</div>
            <div class="plug-list">${portHtml}</div>
          </div>
        `;
      };

      const byEvSuffix = suffix => stations.find(station => String(station.name || "").toUpperCase().includes(`EV${suffix}`));
      const ev3 = byEvSuffix("3");
      const ev5 = byEvSuffix("5");
      const topStations = [ev3, ev5].filter(Boolean);
      const topIds = new Set(topStations.map(station => station.deviceId || station.name));
      const remainingOrder = ["1", "2", "6", "4"];
      const remainingStations = remainingOrder
        .map(suffix => byEvSuffix(suffix))
        .filter(station => station && !topIds.has(station.deviceId || station.name));
      const remainingIds = new Set(remainingStations.map(station => station.deviceId || station.name));
      stations.forEach(station => {
        const id = station.deviceId || station.name;
        if (topIds.has(id) || remainingIds.has(id)) return;
        remainingStations.push(station);
      });

      const topHtml = topStations.length
        ? `<div class="charger-top-row">${topStations.map(renderStationCard).join("")}</div>`
        : "";
      const remainingHtml = remainingStations.length
        ? `<div class="charger-single-row">${remainingStations.map(renderStationCard).join("")}</div>`
        : "";

      list.innerHTML = `${topHtml}${remainingHtml}`;
    }

    function updateChargepointSummary(stations) {
      let available = 0;
      let total = stations.length * CHARGEPOINT_PORTS_PER_STATION;
      for (const station of stations) {
        const ports = station.ports.slice(0, CHARGEPOINT_PORTS_PER_STATION);
        for (const port of ports) {
          if (classifyPortStatus(port.status) === "available") available += 1;
        }
      }
      if (total === 0) total = CHARGEPOINT_LOCATIONS.length * CHARGEPOINT_PORTS_PER_STATION;
      document.getElementById("chargepointSummary").textContent = `Available ${available}/${total}`;
    }

    function updateChargepointUpdated() {
      const updated = new Date().toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
      document.getElementById("chargepointUpdated").textContent = `Updated ${updated}`;
    }

    const chargepointNotifyState = {
      enabled: false,
      until: 0,
      plugAvailability: new Map()
    };

    function updateChargepointNotifyToggleState() {
      const toggle = document.getElementById("chargepointNotifyToggle");
      const stored = loadChargepointNotifyState();
      const now = Date.now();
      if (stored.enabled && stored.until > now && !isAfterNotifyCutoff()) {
        chargepointNotifyState.enabled = true;
        chargepointNotifyState.until = stored.until;
      } else {
        chargepointNotifyState.enabled = false;
        chargepointNotifyState.until = 0;
      }
      toggle.disabled = isAfterNotifyCutoff();
      setChargepointNotifyToggle(chargepointNotifyState.enabled);
    }

    async function handleChargepointNotifyToggle(event) {
      if (isAfterNotifyCutoff()) {
        updateChargepointNotifyToggleState();
        return;
      }
      if (!event.target.checked) {
        chargepointNotifyState.enabled = false;
        chargepointNotifyState.until = 0;
        saveChargepointNotifyState(false, 0);
        return;
      }
      const granted = await requestNotificationPermission();
      if (!granted) {
        event.target.checked = false;
        chargepointNotifyState.enabled = false;
        chargepointNotifyState.until = 0;
        saveChargepointNotifyState(false, 0);
        return;
      }
      const cutoff = getTodayNotifyCutoff().getTime();
      chargepointNotifyState.enabled = true;
      chargepointNotifyState.until = cutoff;
      saveChargepointNotifyState(true, cutoff);
    }

    function checkChargepointNotifications(stations) {
      if (!chargepointNotifyState.enabled) return;
      if (Date.now() > chargepointNotifyState.until || isAfterNotifyCutoff()) {
        chargepointNotifyState.enabled = false;
        chargepointNotifyState.until = 0;
        saveChargepointNotifyState(false, 0);
        updateChargepointNotifyToggleState();
        return;
      }
      const now = Date.now();
      for (const station of stations) {
        const ports = station.ports.slice(0, CHARGEPOINT_PORTS_PER_STATION);
        ports.forEach((port, index) => {
          const plugId = `${station.deviceId || station.name || "station"}-${index}`;
          const state = classifyPortStatus(port.status);
          const entry = chargepointNotifyState.plugAvailability.get(plugId) || { availableSince: 0, notified: false };
          if (state === "available") {
            if (!entry.availableSince) entry.availableSince = now;
            const elapsed = now - entry.availableSince;
            if (elapsed >= CHARGEPOINT_NOTIFY_AFTER_MS && !entry.notified) {
              const stationName = station.name || station.stationName || "ChargePoint";
              sendChargepointNotification(`${stationName} plug ${index + 1} available for 1+ min.`);
              entry.notified = true;
            }
          } else {
            entry.availableSince = 0;
            entry.notified = false;
          }
          chargepointNotifyState.plugAvailability.set(plugId, entry);
        });
      }
    }

    async function fetchChargepointStations() {
      const stations = [];
      for (const location of CHARGEPOINT_LOCATIONS) {
        if (!location.deviceId) {
          stations.push({ deviceId: "", name: location.name, ports: [] });
          continue;
        }
        try {
          const url = new URL(CHARGEPOINT_ENDPOINT);
          url.searchParams.set("deviceId", location.deviceId);
          const res = await fetch(url.toString());
          const data = await res.json();
          const normalized = normalizeChargepointPorts(data);
          stations.push({
            deviceId: location.deviceId,
            name: location.name || normalized.stationName,
            stationName: normalized.stationName,
            ports: normalized.ports
          });
        } catch (err) {
          stations.push({ deviceId: location.deviceId, name: location.name, ports: [] });
        }
      }
      renderChargepointStations(stations);
      updateChargepointSummary(stations);
      updateChargepointUpdated();
      checkChargepointNotifications(stations);
    }

    async function refreshChargepointStations() {
      updateChargepointNotifyToggleState();
      await fetchChargepointStations();
      setTimeout(refreshChargepointStations, CHARGEPOINT_POLL_MS);
    }

    function formatDepartureClock(isoDate) {
      return new Date(isoDate).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    }

    function getDepartureEta(isoDate) {
      const minutes = Math.round((new Date(isoDate).getTime() - Date.now()) / 60000);
      if (minutes <= 0) return "Due";
      if (minutes === 1) return "1 min";
      return `${minutes} min`;
    }

    function getNextEasternDate(dateString) {
      const [year, month, day] = dateString.split("-").map(Number);
      const utcDate = new Date(Date.UTC(year, month - 1, day));
      utcDate.setUTCDate(utcDate.getUTCDate() + 1);
      const y = utcDate.getUTCFullYear();
      const m = String(utcDate.getUTCMonth() + 1).padStart(2, "0");
      const d = String(utcDate.getUTCDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    async function loadAlewifeDepartures(date, minTime) {
      const url = new URL("https://api-v3.mbta.com/schedules");
      url.searchParams.set("filter[stop]", MBTA_STOP_ID);
      url.searchParams.set("filter[route]", MBTA_ROUTE_ID);
      url.searchParams.set("filter[direction_id]", MBTA_DEPARTURE_DIRECTION);
      url.searchParams.set("filter[date]", date);
      url.searchParams.set("filter[min_time]", minTime);
      url.searchParams.set("sort", "departure_time");
      url.searchParams.set("page[limit]", String(MBTA_DEPARTURE_LIMIT));
      url.searchParams.set("include", "trip");
      const res = await fetch(url.toString());
      const payload = await res.json();
      return payload;
    }

    function renderAlewifeDepartures(payload, isTomorrow = false) {
      const rows = Array.isArray(payload.data) ? payload.data : [];
      const trips = new Map(
        (payload.included || [])
          .filter(item => item.type === "trip")
          .map(item => [item.id, item.attributes?.headsign || "Southbound"])
      );
      const updated = new Date().toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
      const updatedLabel = isTomorrow
        ? `Updated ${updated} - showing first trips tomorrow`
        : `Updated ${updated}`;

      if (rows.length === 0) {
        document.getElementById("redlineDepartures").innerHTML = `
          <div class="departure-empty">No departures available right now.</div>
        `;
        document.getElementById("redlineUpdated").textContent = updatedLabel;
        return;
      }

      document.getElementById("redlineDepartures").innerHTML = rows
        .slice(0, MBTA_DEPARTURE_LIMIT)
        .filter(row => row.attributes?.departure_time || row.attributes?.arrival_time)
        .map(row => {
          const departureIso = row.attributes?.departure_time || row.attributes?.arrival_time;
          const tripId = row.relationships?.trip?.data?.id;
          const destination = escapeHtml(trips.get(tripId) || "Southbound");
          return `
            <div class="departure-row">
              <div class="departure-destination">${destination}</div>
              <div class="departure-time">${formatDepartureClock(departureIso)}</div>
              <div class="departure-eta">${getDepartureEta(departureIso)}</div>
            </div>
          `;
        })
        .join("");

      document.getElementById("redlineUpdated").textContent = updatedLabel;
    }

    async function fetchRedLineDepartures() {
      try {
        const nowEastern = getEasternDateTimeParts();
        let payload = await loadAlewifeDepartures(nowEastern.date, nowEastern.time);
        let isTomorrow = false;

        if (!payload.data || payload.data.length === 0) {
          const tomorrow = getNextEasternDate(nowEastern.date);
          payload = await loadAlewifeDepartures(tomorrow, "00:00");
          isTomorrow = true;
        }

        renderAlewifeDepartures(payload, isTomorrow);
      } catch (err) {
        document.getElementById("redlineDepartures").innerHTML = `
          <div class="departure-empty">Unable to load MBTA departure times.</div>
        `;
        document.getElementById("redlineUpdated").textContent = "Updated --";
      }
      setTimeout(fetchRedLineDepartures, 30000);
    }

    function getWeatherIcon(main) {
      main = main.toLowerCase();
      if (main.includes("clear")) return isNight() ? "NIGHT" : "CLEAR";
      if (main.includes("cloud")) return "CLOUD";
      if (main.includes("fog")) return "FOG";
      if (main.includes("rain") || main.includes("drizzle")) return "RAIN";
      if (main.includes("snow")) return "SNOW";
      if (main.includes("thunder")) return "STORM";
      return "WEATHER";
    }

    function celsiusToFahrenheit(valueC) {
      return (valueC * 9) / 5 + 32;
    }

    function formatWeatherTemp(valueC, withUnit = true) {
      const normalized = Number(valueC);
      if (!Number.isFinite(normalized)) return withUnit ? "--" : "--";
      const shown = temperatureUnit === "F" ? celsiusToFahrenheit(normalized) : normalized;
      const rounded = Math.round(shown);
      return withUnit ? `${rounded}&deg;${temperatureUnit}` : `${rounded}&deg;`;
    }

    function updateTempToggleUI() {
      const toggle = document.getElementById("tempUnitToggle");
      const cLabel = document.getElementById("tempUnitCLabel");
      const fLabel = document.getElementById("tempUnitFLabel");
      if (toggle) toggle.checked = temperatureUnit === "F";
      if (cLabel) cLabel.classList.toggle("active", temperatureUnit === "C");
      if (fLabel) fLabel.classList.toggle("active", temperatureUnit === "F");
    }

    function renderWeatherCard(weatherPayload) {
      if (!weatherPayload) return;
      const updatedTs = Number(weatherPayload.lastUpdatedMs || localStorage.getItem(WEATHER_CACHE_UPDATED_KEY) || 0);
      const updatedText = updatedTs ? new Date(updatedTs).toLocaleString([], { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" }) : "--";
      const windSpeed = Number(weatherPayload.wind && weatherPayload.wind.speed);
      const humidity = Number(weatherPayload.main && weatherPayload.main.humidity);
      const precipitation = Number(weatherPayload.precipitation);
      document.getElementById("heroWeather").innerHTML = `
        <div class="weather-main">
          <div class="weather-icon">${getWeatherIcon(weatherPayload.weather[0].main || "")}</div>
          <div>
            <div class="weather-temp">${formatWeatherTemp(weatherPayload.main.temp, true)}</div>
            <div class="weather-condition">${weatherPayload.weather[0].description || weatherPayload.weather[0].main}</div>
          </div>
        </div>
        <div class="weather-stats">
          <div class="weather-stat"><div class="weather-stat-value">${formatWeatherTemp(weatherPayload.main.feels_like, false)}</div><div class="weather-stat-label">Feels like</div></div>
          <div class="weather-stat"><div class="weather-stat-value">${Number.isFinite(humidity) ? `${Math.round(humidity)}%` : "--"}</div><div class="weather-stat-label">Humidity</div></div>
          <div class="weather-stat"><div class="weather-stat-value">${Number.isFinite(windSpeed) ? `${Math.round(windSpeed)} km/h` : "--"}</div><div class="weather-stat-label">Wind</div></div>
          <div class="weather-stat"><div class="weather-stat-value">${Number.isFinite(precipitation) ? `${precipitation.toFixed(1)} mm` : "--"}</div><div class="weather-stat-label">Precipitation</div></div>
          <div class="weather-stat"><div class="weather-stat-value">${Number.isFinite(weatherPayload.uv_index) ? weatherPayload.uv_index.toFixed(1) : "--"}</div><div class="weather-stat-label">UV index</div></div>
        </div>
        <div class="weather-meta">Last updated ${updatedText} - <a href="https://open-meteo.com/" target="_blank" rel="noopener noreferrer">Weather data by Open-Meteo.com</a></div>
      `;
    }

    function getNextWeatherRefreshDelayMs() {
      const span = WEATHER_REFRESH_MAX_MS - WEATHER_REFRESH_MIN_MS;
      return WEATHER_REFRESH_MIN_MS + Math.floor(Math.random() * (span + 1));
    }

    async function fetchMenu() {
      const menuUrl = "https://raw.githubusercontent.com/Char1esQian/cambridgedashboard/refs/heads/main/menu.json";
      const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const today = weekdays[new Date().getDay()];
      const isWeekend = today === "Saturday" || today === "Sunday";
      document.getElementById("menuDay").textContent = today;
      try {
        const res = await fetch(menuUrl);
        const data = await res.json();
        const todayMenu = data[today];
        if (!todayMenu) {
          document.getElementById("menuContent").innerHTML = `<span class="loading">No menu for ${today}</span>`;
          updateMenuActionItem([]);
          if (isWeekend) {
            const label = document.getElementById("menuActionName");
            if (label) label.textContent = "Weekend";
            setMenuHighlightGrid([{ category: "Weekend", name: "No menu items", imageUrl: WEEKEND_NO_MENU_IMAGE_URL }]);
            setMenuImageStatus(`Weekend: no menu items available for ${today}.`, false);
          } else {
            setMenuImageStatus(`No menu items available for ${today}.`, true);
          }
          return;
        }
        const entries = Object.entries(todayMenu).map(([category, item]) => [category, normalizeMenuItemForDisplay(item)]);
        const byCategory = new Map(entries.map(([category, item]) => [String(category).toLowerCase(), { category, item }]));
        const dailyMetaRaw = data && data._generated && data._generated.dailyHighlights ? data._generated.dailyHighlights[today] : null;
        const dailyMeta = normalizeDailyHighlightMeta(dailyMetaRaw);
        let highlightItems = [];
        if (dailyMeta.length) {
          highlightItems = dailyMeta.map(meta => {
            const category = String((meta && meta.category) || "").trim();
            const matched = byCategory.get(category.toLowerCase());
            const item = matched ? matched.item : null;
            const fallbackItem = item || normalizeMenuItemForDisplay(meta || {});
            return {
              category: category || (matched ? matched.category : "Highlight"),
              name: fallbackItem.name || String((meta && meta.name) || "Menu highlight"),
              imageUrl: String((meta && meta.imageUrl) || fallbackItem.imageUrl || "")
            };
          }).filter(it => it.name || it.imageUrl);
        }
        if (!highlightItems.length) {
          highlightItems = pickActionMenuItems(entries).map(entry => ({
            category: entry.category,
            name: entry.item.name,
            imageUrl: entry.item.imageUrl || ""
          }));
        }
        updateMenuActionItem(highlightItems);
        document.getElementById("menuContent").innerHTML = entries.map(([category, item]) => `
          <div class="menu-item">
            <div class="menu-category">${category}</div>
            <div class="menu-name">${item.name}</div>
            ${item.description ? `<div class="menu-desc">${item.description}</div>` : ''}
            <div class="menu-price">${item.price || "Market Price"}</div>
          </div>
        `).join("");
      } catch (err) {
        document.getElementById("menuContent").innerHTML = `<span class="loading">Unable to load menu</span>`;
        updateMenuActionItem([]);
        setMenuImageStatus("Unable to load menu items.", true);
      }
    }

    async function fetchWeather() {
      try {
        const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,wind_gusts_10m,cloud_cover,pressure_msl,uv_index,is_day&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max&forecast_days=5&timezone=America%2FNew_York&timeformat=unixtime`;
        const res = await fetch(weatherUrl);
        if (!res.ok) throw new Error(`Weather request failed: ${res.status}`);
        const raw = await res.json();
        const w = normalizeOpenMeteoCurrent(raw);
        if (!w) throw new Error("Missing current weather payload");

        currentWeatherMain = w.weather[0].main || currentWeatherMain || "Clouds";
        localStorage.setItem(WEATHER_CACHE_KEY, currentWeatherMain);
        localStorage.setItem(WEATHER_CACHE_TS_KEY, String(Date.now()));
        localStorage.setItem(WEATHER_CACHE_PAYLOAD_KEY, JSON.stringify(w));
        localStorage.setItem(WEATHER_CACHE_UPDATED_KEY, String(w.lastUpdatedMs));
        latestWeatherPayload = w;
        weatherSceneReady = true;
        weatherSceneSyncKey = "";
        updateWeatherScene(currentWeatherMain);
        renderWeatherCard(w);
      } catch (err) {
        currentWeatherMain = currentWeatherMain || "Clouds";
        weatherSceneReady = true;
        weatherSceneSyncKey = "";
        updateWeatherScene(currentWeatherMain);
        if (latestWeatherPayload) {
          renderWeatherCard(latestWeatherPayload);
        } else {
          document.getElementById("heroWeather").innerHTML = `
            <div class="weather-main"><div class="weather-icon">OFFLINE</div><div><div class="weather-temp">--</div><div class="weather-condition">Unavailable</div></div></div>
            <div class="weather-meta"><a href="https://open-meteo.com/" target="_blank" rel="noopener noreferrer">Weather data by Open-Meteo.com</a></div>
          `;
        }
      }
      setTimeout(fetchWeather, getNextWeatherRefreshDelayMs());
    }

    updateGreeting();
    applyWeekendLayoutState();
    updateTempToggleUI();
    if (latestWeatherPayload) {
      renderWeatherCard(latestWeatherPayload);
    }
    if (currentWeatherMain) {
      weatherSceneReady = true;
      updateWeatherScene(currentWeatherMain);
    }
    updateClock();
    refreshBikes();
    fetchWeather();
    fetchMenu();
    fetchRedLineDepartures();
    refreshSportsPanel();
    setMenuPanelCollapsedState(localStorage.getItem(MENU_PANEL_COLLAPSED_KEY) === "true");
    setEvPanelOpenState(localStorage.getItem(EV_PANEL_OPEN_KEY) === "true");
    const bikeHeader = document.querySelector("#bikeExpandable .expandable-header");
    if (bikeHeader) {
      bikeHeader.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggleBikes();
        }
      });
    }
    const evHeader = document.querySelector("#evExpandable .expandable-header");
    if (evHeader) {
      evHeader.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggleEvPanel();
        }
      });
    }
    const sportsHeader = document.querySelector("#sportsExpandable .expandable-header");
    if (sportsHeader) {
      sportsHeader.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggleSportsPanel();
        }
      });
    }
    const tempUnitToggle = document.getElementById("tempUnitToggle");
    if (tempUnitToggle) {
      tempUnitToggle.addEventListener("change", event => {
        temperatureUnit = event.target.checked ? "F" : "C";
        localStorage.setItem(TEMP_UNIT_STORAGE_KEY, temperatureUnit);
        updateTempToggleUI();
        if (latestWeatherPayload) {
          renderWeatherCard(latestWeatherPayload);
        }
      });
    }
    document.getElementById("chargepointNotifyToggle").addEventListener("change", handleChargepointNotifyToggle);
    refreshChargepointStations();
  </script>
</body>

</html>

